<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SwitchBot Device Manager - Light Engine Charlie</title>
  <link rel="stylesheet" href="./styles.charlie.css?v=charlie-0.5">
  <style>
    body {
      margin: 0;
      font-family: var(--gr-font, 'Segoe UI', sans-serif);
      background: var(--gr-bg, #f7fafa);
      color: var(--gr-text, #0b1220);
    }

    .page-container {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .switchbot-header {
      background: linear-gradient(135deg, var(--gr-primary, #0d7d7d), var(--gr-primary-hover, #0c6f6f));
      color: var(--gr-surface, #ffffff);
      padding: 28px;
      border-radius: 20px;
      box-shadow: var(--gr-shadow-lg, 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 10px 10px -5px rgb(0 0 0 / 0.04));
      margin-bottom: 24px;
    }

    .switchbot-header h1 {
      margin: 0;
      font-size: 28px;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .switchbot-header p {
      margin: 12px 0 0;
      font-size: 15px;
      opacity: 0.9;
    }

    .switchbot-header details {
      margin-top: 18px;
      background: rgb(255 255 255 / 0.12);
      border-radius: 14px;
      padding: 12px 16px;
    }

    .switchbot-header summary {
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.02em;
      list-style: none;
    }

    .switchbot-header summary::marker {
      display: none;
    }

    .switchbot-header details[open] summary {
      margin-bottom: 8px;
    }

    .switchbot-header details div {
      font-size: 13px;
      line-height: 1.6;
      color: var(--gr-surface, #ffffff);
      opacity: 0.95;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .section-header h2 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .device-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 20px;
      margin: 20px 0 32px;
    }

    .device-card {
      border: 1px solid var(--gr-border, #dce5e5);
      border-radius: 16px;
      padding: 20px;
      background: var(--gr-surface, #ffffff);
      box-shadow: var(--gr-shadow, 0 8px 16px -8px rgb(15 23 42 / 0.2));
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-height: 220px;
    }

    .device-card:hover {
      transform: translateY(-3px);
      box-shadow: var(--gr-shadow-lg, 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 10px 10px -5px rgb(0 0 0 / 0.04));
    }

    .device-header {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      align-items: flex-start;
    }

    .device-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .device-header .meta {
      font-size: 13px;
      color: #4d5562;
      margin-top: 4px;
    }

    .device-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .device-avatar {
      width: 52px;
      height: 52px;
      border-radius: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 18px;
      background: rgba(13, 125, 125, 0.12);
      color: var(--gr-primary, #0d7d7d);
      border: 1px solid rgba(13, 125, 125, 0.25);
      flex-shrink: 0;
    }

    .device-avatar.tone-energy {
      background: rgba(79, 70, 229, 0.12);
      border-color: rgba(79, 70, 229, 0.25);
      color: #4338ca;
    }

    .device-avatar.tone-safety {
      background: rgba(209, 67, 67, 0.1);
      border-color: rgba(209, 67, 67, 0.25);
      color: #b91c1c;
    }

    .device-avatar.tone-automation {
      background: rgba(240, 165, 0, 0.12);
      border-color: rgba(240, 165, 0, 0.28);
      color: #b45309;
    }

    .control-button {
      padding: 8px 16px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: var(--gr-border, #dce5e5);
      color: var(--gr-text, #0b1220);
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
    }

    .control-button.on {
      background: var(--gr-primary, #0d7d7d);
      color: var(--gr-surface, #ffffff);
      box-shadow: 0 10px 20px -12px var(--gr-primary, #0d7d7d);
    }

    .control-button.off {
      background: var(--gr-surface, #ffffff);
      border-color: var(--gr-border, #dce5e5);
      color: #0f172a;
    }

    .control-button.secondary {
      background: var(--gr-accent-soft, #e9f8f8);
      color: var(--gr-primary, #0d7d7d);
    }

    .control-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px -14px rgb(15 23 42 / 0.35);
    }

    .control-button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .device-status {
      display: inline-flex;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      margin-right: 8px;
      background: var(--gr-border, #dce5e5);
      position: relative;
    }

    .device-status::after {
      content: '';
      position: absolute;
      inset: -3px;
      border-radius: inherit;
      border: 1px solid transparent;
    }

    .status-online {
      background: #0f9b74;
    }

    .status-online::after {
      border-color: rgba(15, 155, 116, 0.35);
    }

    .status-offline {
      background: #d14343;
    }

    .status-offline::after {
      border-color: rgba(209, 67, 67, 0.35);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid transparent;
      background: var(--gr-surface, #ffffff);
      color: var(--gr-text, #0b1220);
      min-width: 70px;
    }

    .status-badge.tone-positive {
      background: rgba(15, 155, 116, 0.12);
      border-color: rgba(15, 155, 116, 0.4);
      color: #0f9b74;
    }

    .status-badge.tone-warning {
      background: rgba(240, 165, 0, 0.12);
      border-color: rgba(240, 165, 0, 0.4);
      color: #b45309;
    }

    .status-badge.tone-critical {
      background: rgba(209, 67, 67, 0.12);
      border-color: rgba(209, 67, 67, 0.45);
      color: #b91c1c;
    }

    .status-badge.tone-neutral {
      background: rgba(79, 70, 229, 0.08);
      border-color: rgba(79, 70, 229, 0.25);
      color: #4338ca;
    }

    .reading-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .reading-item {
      background: var(--gr-primary-soft, #e6f0f0);
      border-radius: 12px;
      border: 1px solid var(--gr-border, #dce5e5);
      padding: 14px 16px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 90px;
    }

    .reading-value {
      font-size: 20px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .reading-label {
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #4d5562;
    }

    .reading-item[data-tone="warning"] {
      background: rgba(240, 165, 0, 0.1);
      border-color: rgba(240, 165, 0, 0.3);
    }

    .reading-item[data-tone="critical"] {
      background: rgba(209, 67, 67, 0.12);
      border-color: rgba(209, 67, 67, 0.35);
    }

    .reading-item[data-tone="positive"] {
      background: rgba(15, 155, 116, 0.1);
      border-color: rgba(15, 155, 116, 0.3);
    }

    .sync-status {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 18px;
      background: var(--gr-surface, #ffffff);
      border-radius: 14px;
      border: 1px solid var(--gr-border, #dce5e5);
      box-shadow: var(--gr-shadow, 0 8px 16px -12px rgb(15 23 42 / 0.3));
      margin-bottom: 24px;
    }

    .sync-indicator {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: var(--gr-primary, #0d7d7d);
      position: relative;
      overflow: hidden;
    }

    .sync-indicator::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      box-shadow: 0 0 0 0 rgba(13, 125, 125, 0.3);
      animation: syncPulse 2s infinite;
    }

    .sync-indicator.error {
      background: #d14343;
    }

    .sync-indicator.error::after {
      animation: none;
      box-shadow: none;
    }

    @keyframes syncPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(13, 125, 125, 0.3);
      }
      70% {
        box-shadow: 0 0 0 6px rgba(13, 125, 125, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(13, 125, 125, 0);
      }
    }

    .error-message {
      background: rgba(209, 67, 67, 0.08);
      border: 1px solid rgba(209, 67, 67, 0.35);
      color: #7f1d1d;
      padding: 16px;
      border-radius: 12px;
      margin: 20px 0;
    }

    .info-message {
      background: rgba(79, 70, 229, 0.08);
      border: 1px solid rgba(79, 70, 229, 0.25);
      color: #312e81;
      padding: 16px;
      border-radius: 12px;
      margin: 20px 0;
    }

    .loading {
      text-align: center;
      padding: 48px;
      color: #4d5562;
      font-size: 15px;
    }

    .device-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .device-summary-item {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--gr-border, #dce5e5);
      background: var(--gr-surface, #ffffff);
      min-width: 140px;
      box-shadow: var(--gr-shadow, 0 8px 16px -14px rgb(15 23 42 / 0.25));
    }

    .device-summary-item.tone-positive {
      border-color: rgba(15, 155, 116, 0.35);
      background: rgba(15, 155, 116, 0.08);
    }

    .device-summary-item.tone-warning {
      border-color: rgba(240, 165, 0, 0.35);
      background: rgba(240, 165, 0, 0.08);
    }

    .device-summary-item.tone-critical {
      border-color: rgba(209, 67, 67, 0.35);
      background: rgba(209, 67, 67, 0.08);
    }

    .device-summary-value {
      font-size: 16px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .device-summary-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #4d5562;
      margin-top: 4px;
    }

    .device-type-badge.real-device {
      background: rgba(15, 155, 116, 0.12);
      color: #0f9b74;
      border: 1px solid rgba(15, 155, 116, 0.3);
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(15, 155, 116, 0.1);
      border: 1px solid rgba(15, 155, 116, 0.3);
      color: #0f9b74;
      font-weight: 600;
    }

    .pulse-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #0f9b74;
      position: relative;
      overflow: hidden;
    }

    .pulse-dot::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      box-shadow: 0 0 0 0 rgba(15, 155, 116, 0.4);
      animation: syncPulse 2s infinite;
    }

    .device-status.online {
      color: #0f9b74;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="page-container">
    <div class="switchbot-header">
      <h1>SwitchBot Device Manager</h1>
      <p>Live monitoring and control of SwitchBot devices with comprehensive data.</p>
      <details>
        <summary>Available Data Fields</summary>
        <div>
          <strong>Environmental:</strong> Temperature, Humidity, CO2, Light Level, Motion Detection<br>
          <strong>Power:</strong> On/Off Status, Voltage, Current, Daily Usage, Power Consumption<br>
          <strong>Device:</strong> Battery Level, Signal Strength, Firmware Version, Connection Type<br>
          <strong>Management:</strong> Zone Assignment, Farm Location, Equipment Control
        </div>
      </details>
      <details>
        <summary>Control Guardrails</summary>
        <div>
          <strong>North Star:</strong>
          <ul>
            <li>Manage rooms and zones in Farm Setup; device and group cards provide progressively narrower context.</li>
            <li>Typed groups with guardrails prevent lighting plans from colliding with environmental automation.</li>
          </ul>
          <strong>Control Contracts:</strong>
          <ul>
            <li>SwitchBot sensors feed zone targets and control intent via the <code>/env</code> contract.</li>
            <li>Lights follow spectrum plans and schedules from <code>/plans</code> and <code>/sched</code>; avoid mixing plug automation with those payloads.</li>
          </ul>
          <strong>Golden Rules for Plugs:</strong>
          <ol>
            <li>When a light has a direct API, run it through <code>/sched</code> HEX12 payloads and force its plug ON—reserve the plug for emergency kills.</li>
            <li>Gate only non-dimmable or API-less lights with plugs and exclude them from schedule applications.</li>
            <li>Drive dehumidifiers, fans, and heaters through plug or relay automation tied to <code>/env</code> targets, never lighting schedules.</li>
            <li>Set plug-controlled lights to <code>controlPriority: "plug_only"</code> so schedules stay off that circuit.</li>
          </ol>
        </div>
      </details>
    </div>

    <div class="sync-status" id="syncStatus">
      <div class="sync-indicator" id="syncIndicator"></div>
      <span id="syncText">Loading environment data...</span>
      <button id="btnRefresh" type="button" class="ghost" style="margin-left: auto;">Refresh</button>
    </div>

    <div class="section-header">
      <div>
        <h2>SwitchBot Devices</h2>
        <p class="tiny" style="margin: 4px 0 0; color: #64748b;" id="deviceCount">Loading...</p>
      </div>
      <div class="row" style="gap: 8px;">
        <button id="btnStartPolling" type="button" class="primary">Start Polling</button>
        <button id="btnOpenMain" type="button" class="ghost">Back to Dashboard</button>
      </div>
    </div>

    <div id="errorContainer"></div>
    <div id="infoContainer"></div>
    <div id="loadingContainer" class="loading" style="display: none;">
      <div>Loading devices...</div>
    </div>
    
    <div id="devicesContainer" class="device-grid">
      <!-- Devices will be loaded here -->
    </div>
  </div>

  <script>
function toNumberOrNull(val) {
  var n = Number(val);
  return isNaN(n) ? null : n;
}
    let devices = [];
    let syncInterval = null;
    let environmentData = [];
    const deviceMetadataMap = new Map();
    let deviceMetadataLoaded = false;
    let deviceMetadataPromise = null;
    let baseZoneOptions = [];
    let zoneOptionsLocked = false;
    let baseRoomOptions = [];
    let baseLevelOptions = [];
    let baseSideOptions = [];
    let availableZones = [];
    let availableRooms = [];
    let availableLevels = [];
    let availableSides = [];
    const fallbackCounters = { zone: 0, room: 0, level: 0, side: 0 };
    let groupCatalog = [];
    let groupCatalogLoaded = false;

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function escapeAttribute(value) {
      return escapeHtml(value);
    }

    function slugify(value) {
      return String(value ?? '')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    }

    function nextFallbackValue(prefix) {
      fallbackCounters[prefix] = (fallbackCounters[prefix] || 0) + 1;
      return `${prefix}-${fallbackCounters[prefix]}`;
    }

    function domSafeId(value) {
      return String(value ?? '').replace(/[^a-zA-Z0-9_-]/g, '_');
    }

    const CONTROLLED_TYPE_OPTIONS = ['dehumidifier', 'fan', 'light', 'heater', 'misc'];
    const CRITICALITY_OPTIONS = ['safety', 'comfort', 'optional'];
    const ENERGY_TELEMETRY_OPTIONS = ['plug_builtin', 'branch_meter', 'none'];
    const SENSOR_METRIC_ORDER = ['temp', 'rh', 'co2', 'vpd'];

    function toNumeric(value) {
      if (value === undefined || value === null) return null;
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
      }
      if (typeof value === 'string') {
        const match = value.match(/-?\d+(?:\.\d+)?/);
        if (match) {
          const parsed = Number(match[0]);
          return Number.isFinite(parsed) ? parsed : null;
        }
      }
      return null;
    }

    function coalesceNumeric(...values) {
      for (const candidate of values) {
        const numeric = toNumeric(candidate);
        if (numeric !== null) {
          return numeric;
        }
      }
      return null;
    }

    function firstString(...values) {
      for (const candidate of values) {
        if (typeof candidate === 'string' && candidate.trim()) {
          return candidate.trim();
        }
      }
      return '';
    }

    function equalsIgnoreCase(a, b) {
      if (a === undefined || a === null || b === undefined || b === null) return false;
      return String(a).trim().toLowerCase() === String(b).trim().toLowerCase();
    }

    function matchesAny(value, candidates = []) {
      if (!value && value !== 0) return false;
      return candidates.some(candidate => equalsIgnoreCase(candidate, value));
    }

    function clampWeight(value, fallback = null) {
      const numeric = toNumeric(value);
      if (numeric !== null) {
        return Math.max(0, Math.min(1, numeric));
      }
      if (fallback === null || fallback === undefined) {
        return null;
      }
      const fallbackNumeric = toNumeric(fallback);
      return fallbackNumeric === null ? null : Math.max(0, Math.min(1, fallbackNumeric));
    }

    function normalizeSensorMetric(metric) {
      if (!metric && metric !== 0) return null;
      const normalized = String(metric).trim().toLowerCase();
      if (!normalized) return null;
      if (['temp', 'temperature', 'temp_c', 'tempc', 'tempf', 'temp_f'].includes(normalized)) return 'temp';
      if (['humidity', 'rh', 'relative_humidity', 'relative-humidity'].includes(normalized)) return 'rh';
  if (['co2', 'co2ppm', 'co2_ppm', 'carbon_dioxide', 'carbon-dioxide'].includes(normalized)) return 'co2';
      if (['vpd', 'vapour_pressure_deficit', 'vapor_pressure_deficit', 'vapour-pressure-deficit'].includes(normalized)) return 'vpd';
      return null;
    }

    function deriveSensorMetrics(device, metadata) {
      const metrics = new Set();
      const existingMetrics = Array.isArray(device?.metrics) ? device.metrics : [];
      existingMetrics.forEach(metric => {
        const normalized = normalizeSensorMetric(metric);
        if (normalized) metrics.add(normalized);
      });

      const metaDetails = metadata?.details || {};
      const metaMetrics = Array.isArray(metadata?.metrics)
        ? metadata.metrics
        : Array.isArray(metaDetails.metrics)
        ? metaDetails.metrics
        : [];
      metaMetrics.forEach(metric => {
        const normalized = normalizeSensorMetric(metric);
        if (normalized) metrics.add(normalized);
      });

      const reading = device?.lastReading || {};
      const sensorCandidates = [
        reading,
        reading.readings,
        reading.latest,
        reading.metrics,
        reading.sensors
      ];
      sensorCandidates.forEach(source => {
        if (!source || typeof source !== 'object') return;
        const normalizedSource = source;
        if (normalizedSource.temperature !== undefined || normalizedSource.temp !== undefined || normalizedSource.tempC !== undefined) {
          metrics.add('temp');
        }
        if (normalizedSource.humidity !== undefined || normalizedSource.rh !== undefined) {
          metrics.add('rh');
        }
        if (
          normalizedSource.co2 !== undefined ||
          normalizedSource.co2ppm !== undefined ||
          normalizedSource.co2Ppm !== undefined ||
          normalizedSource.co2 !== undefined
        ) {
          metrics.add('co2');
        }
        if (normalizedSource.vpd !== undefined) {
          metrics.add('vpd');
        }
        if (normalizedSource.tempC && (normalizedSource.tempC.current !== undefined || normalizedSource.tempC.value !== undefined)) {
          metrics.add('temp');
        }
        if (normalizedSource.rh && (normalizedSource.rh.current !== undefined || normalizedSource.rh.value !== undefined)) {
          metrics.add('rh');
        }
        if (normalizedSource.co2 && (normalizedSource.co2.current !== undefined || normalizedSource.co2.value !== undefined)) {
          metrics.add('co2');
        }
        if (normalizedSource.vpd && (normalizedSource.vpd.current !== undefined || normalizedSource.vpd.value !== undefined)) {
          metrics.add('vpd');
        }
      });

      return SENSOR_METRIC_ORDER.filter(metric => metrics.has(metric));
    }

    function normalizeControlledType(value) {
      if (!value && value !== 0) return null;
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) return null;
      if (CONTROLLED_TYPE_OPTIONS.includes(normalized)) return normalized;
      if (normalized.includes('dehum')) return 'dehumidifier';
      if (normalized.includes('fan')) return 'fan';
      if (normalized.includes('light') || normalized.includes('lamp') || normalized.includes('grow')) return 'light';
      if (normalized.includes('heat')) return 'heater';
      return null;
    }

    function normalizeCriticality(value) {
      if (!value && value !== 0) return null;
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) return null;
      if (CRITICALITY_OPTIONS.includes(normalized)) return normalized;
      if (normalized.includes('safety') || normalized.includes('critical')) return 'safety';
      if (normalized.includes('comfort') || normalized.includes('climate')) return 'comfort';
      return null;
    }

    function normalizeEnergyTelemetry(value) {
      if (!value && value !== 0) return null;
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) return null;
      if (ENERGY_TELEMETRY_OPTIONS.includes(normalized)) return normalized;
      if (normalized.includes('branch')) return 'branch_meter';
      if (normalized.includes('builtin') || normalized.includes('built-in') || normalized.includes('plug')) return 'plug_builtin';
      if (normalized.includes('none') || normalized.includes('n/a') || normalized.includes('na')) return 'none';
      return null;
    }

    function guessPlugControlledType(device, metadata) {
      const metaDetails = metadata?.details || {};
      const fromMeta = normalizeControlledType(
        metadata?.controlledType ||
          metaDetails.controlledType ||
          metaDetails.equipmentCategory ||
          metadata?.equipmentCategory
      );
      if (fromMeta) return fromMeta;
      const context = [
        device?.managedEquipment,
        metaDetails.managedEquipment,
        metaDetails.equipment,
        metadata?.managedEquipment,
        device?.displayName,
        device?.deviceName,
        device?.deviceType
      ]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      if (context.includes('dehum')) return 'dehumidifier';
      if (context.includes('fan')) return 'fan';
      if (context.includes('light') || context.includes('lamp') || context.includes('grow')) return 'light';
      if (context.includes('heat') || context.includes('heater')) return 'heater';
      return 'misc';
    }

    function guessPlugCriticality(device, controlledType, metadata) {
      const metaDetails = metadata?.details || {};
      const fromMeta = normalizeCriticality(metadata?.criticality || metaDetails.criticality);
      if (fromMeta) return fromMeta;
      const context = [
        device?.managedEquipment,
        metaDetails.managedEquipment,
        metadata?.managedEquipment,
        device?.displayName,
        device?.deviceName,
        device?.deviceType
      ]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      if (
        context.includes('alarm') ||
        context.includes('security') ||
        context.includes('safety') ||
        context.includes('pump') ||
        context.includes('irrigation')
      ) {
        return 'safety';
      }
      if (controlledType === 'dehumidifier' || controlledType === 'fan' || controlledType === 'heater') {
        return 'comfort';
      }
      return 'optional';
    }

    function guessEnergyTelemetry(device, metadata) {
      const metaDetails = metadata?.details || {};
      const fromMeta = normalizeEnergyTelemetry(
        metadata?.energyTelemetry ||
          metaDetails.energyTelemetry ||
          metaDetails.energySource ||
          metadata?.energySource
      );
      if (fromMeta) return fromMeta;
      const reading = device?.lastReading || {};
      if (
        reading.wattage !== undefined ||
        reading.weight !== undefined ||
        reading.power !== undefined ||
        reading.electricityOfDay !== undefined ||
        reading.voltage !== undefined ||
        reading.electricCurrent !== undefined
      ) {
        return 'plug_builtin';
      }
      return 'none';
    }

    function buildPlacementEntry(option, fallbackLabel) {
      if (option) {
        return {
          id: option.id || null,
          name: option.name,
          value: option.value || option.id || null,
          source: 'farm'
        };
      }
      if (fallbackLabel) {
        return {
          id: null,
          name: fallbackLabel,
          value: null,
          source: 'unmapped'
        };
      }
      return null;
    }

    function buildPlacement(device, metadata) {
      const metaDetails = metadata?.details || {};
      const zoneCandidates = [
        device?.zoneId,
        metadata?.zoneId,
        metaDetails.zoneId,
        metadata?.zoneSlug,
        metaDetails.zoneSlug
      ];
      let zoneOption = null;
      for (const candidate of zoneCandidates) {
        zoneOption = findZoneOption(candidate);
        if (zoneOption) break;
      }
      const zoneLabelCandidates = [
        device?.zoneName,
        metadata?.zoneName,
        metadata?.zone,
        metaDetails.zoneName,
        metaDetails.zone,
        device?.lastReading?.zone,
        device?.lastReading?.name
      ];
      const zoneLabel = zoneLabelCandidates.find(label => typeof label === 'string' && label.trim());
      const zonePlacement = buildPlacementEntry(zoneOption, zoneLabel);

      const roomCandidates = [
        device?.farmLocationId,
        metadata?.roomId,
        metaDetails.roomId,
        metadata?.roomSlug,
        metaDetails.roomSlug
      ];
      let roomOption = null;
      for (const candidate of roomCandidates) {
        roomOption = findRoomOption(candidate);
        if (roomOption) break;
      }
      const roomLabelCandidates = [
        device?.farmLocation,
        metadata?.roomName,
        metadata?.room,
        metadata?.location,
        metaDetails.roomName,
        metaDetails.room,
        device?.lastReading?.location
      ];
      const roomLabel = roomLabelCandidates.find(label => typeof label === 'string' && label.trim());
      const roomPlacement = buildPlacementEntry(roomOption, roomLabel);

      const level =
        metaDetails.level ||
        metaDetails.rackLevel ||
        metaDetails.tier ||
        metaDetails.shelf ||
        metadata?.level ||
        (typeof device?.placement?.level === 'object' ? device.placement.level.value || device.placement.level.name : device?.placement?.level) ||
        null;
      const side =
        metaDetails.side ||
        metaDetails.orientation ||
        metaDetails.aisle ||
        metadata?.side ||
        (typeof device?.placement?.side === 'object' ? device.placement.side.value || device.placement.side.name : device?.placement?.side) ||
        null;

      const levelOption = level ? findLevelOption(level) : null;
      const sideOption = side ? findSideOption(side) : null;

      return {
        zone: zonePlacement,
        room: roomPlacement,
        level: buildPlacementEntry(levelOption, level),
        side: buildPlacementEntry(sideOption, side)
      };
    }

    function deriveRole(device, metadata) {
      const metaDetails = metadata?.details || {};
      const candidate = (metadata?.role || metaDetails.role || '').toLowerCase();
      if (candidate === 'sensor') return 'sensor';
      if (candidate === 'plug' || candidate === 'actuator' || candidate === 'switch') return 'plug';
      return isSensorDevice(device?.deviceType) ? 'sensor' : 'plug';
    }

    function syncDeviceCardSchema(device, metadata) {
      if (!device) return;
      const canonicalId = getCanonicalDeviceId(device) || device.deviceId || device.device_id || '';
      if (!device.deviceId) {
        device.deviceId = canonicalId;
      }
      const reading = device.lastReading || {};
      const metaDetails = metadata?.details || {};
      const batteryLevel = coalesceNumeric(
        reading.battery,
        reading.meta?.battery,
        reading.version?.battery,
        device.battery,
        metaDetails.battery,
        device.identity?.battery
      );
      const signalLevel = coalesceNumeric(
        reading.rssi,
        reading.meta?.rssi,
        reading.signal,
        reading.version?.rssi,
        device.rssi,
        metaDetails.signal,
        device.identity?.signal
      );
      const displayName =
        device.displayName ||
        metadata?.name ||
        metadata?.deviceName ||
        metaDetails.displayName ||
        device.deviceName ||
        device.name ||
        canonicalId;

      const lastSeen = firstString(
        reading.lastUpdate,
        reading.timestamp,
        reading.meta?.lastUpdate,
        metadata?.lastSeen,
        metaDetails.lastSeen,
        device.identity?.lastSeen
      );

      device.identity = {
        deviceId: canonicalId,
        name: displayName,
        battery: batteryLevel,
        signal: signalLevel,
        lastSeen: lastSeen || null
      };

      device.placement = buildPlacement(device, metadata);

      const role = deriveRole(device, metadata);
      device.role = role;

      if (role === 'sensor') {
        device.metrics = deriveSensorMetrics(device, metadata);
        const weightFromMeta = clampWeight(metaDetails.weight ?? metadata?.weight, null);
        const existingWeight = clampWeight(device.weight, null);
        device.weight = weightFromMeta ?? existingWeight ?? null;
        if (metaDetails.primary !== undefined || metadata?.primary !== undefined) {
          device.primary = Boolean(metaDetails.primary ?? metadata?.primary);
        } else if (device.primary === undefined) {
          device.primary = false;
        } else {
          device.primary = Boolean(device.primary);
        }
        delete device.controlledType;
        delete device.criticality;
        delete device.controlMethod;
        delete device.energyTelemetry;
        delete device.controlPriority;
      } else {
        delete device.metrics;
        delete device.weight;
        delete device.primary;
        delete device.controlPriority;
        const controlledType = guessPlugControlledType(device, metadata);
        device.controlledType = controlledType;
        device.criticality = guessPlugCriticality(device, controlledType, metadata);
        device.controlMethod = 'plug_onoff';
        device.energyTelemetry = guessEnergyTelemetry(device, metadata);
        if (controlledType === 'light') {
          device.controlPriority = 'plug_only';
        }
      }
    }

    function recalculateSensorWeights() {
      const sensorsByZone = new Map();
      devices.forEach(device => {
        if (!device || device.role !== 'sensor') return;
        const zoneKey =
          (device.placement && device.placement.zone && device.placement.zone.value) ||
          device.zoneId ||
          (device.placement && device.placement.zone && device.placement.zone.name) ||
          '__unassigned__';
        if (!sensorsByZone.has(zoneKey)) {
          sensorsByZone.set(zoneKey, []);
        }
        sensorsByZone.get(zoneKey).push(device);
      });

      sensorsByZone.forEach(devicesInZone => {
        if (!devicesInZone.length) return;
        const explicitPrimary = devicesInZone.filter(device => device.primary === true);
        if (explicitPrimary.length === 0) {
          let chosen = devicesInZone[0];
          let highestBattery = -Infinity;
          devicesInZone.forEach(device => {
            const battery = toNumeric(device.identity?.battery ?? device.lastReading?.battery);
            if (battery !== null && battery > highestBattery) {
              highestBattery = battery;
              chosen = device;
            }
          });
          devicesInZone.forEach(device => {
            device.primary = device === chosen;
          });
        } else {
          devicesInZone.forEach(device => {
            device.primary = explicitPrimary.includes(device);
          });
        }

        const explicitWeights = devicesInZone.filter(device => device.weight !== null && device.weight !== undefined);
        if (explicitWeights.length === devicesInZone.length) {
          devicesInZone.forEach(device => {
            device.weight = clampWeight(device.weight, 0);
          });
        } else {
          const defaultWeight = devicesInZone.length > 0 ? clampWeight(1 / devicesInZone.length, 0) : 0;
          devicesInZone.forEach(device => {
            if (device.weight === null || device.weight === undefined) {
              device.weight = defaultWeight;
            } else {
              device.weight = clampWeight(device.weight, defaultWeight);
            }
          });
        }
      });
    }

    function getZoneKey(device) {
      if (!device) return '__unassigned__';
      const placement = device.placement || {};
      return (
        firstString(
          placement.zone?.value,
          placement.zone?.id,
          placement.zone?.name,
          device.zoneId,
          device.zoneName
        ) || '__unassigned__'
      );
    }

    function getZoneSensors(device) {
      const zoneKey = getZoneKey(device);
      return devices.filter(candidate => candidate && candidate.role === 'sensor' && getZoneKey(candidate) === zoneKey);
    }

    function computeMedian(values) {
      if (!Array.isArray(values) || values.length === 0) return 0;
      const sorted = values.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      }
      return sorted[mid];
    }

    function computeZoneWeightStats(device) {
      const sensors = getZoneSensors(device);
      if (!sensors.length) {
        return { median: 0, average: 0, total: 0, count: 0 };
      }
      const weights = sensors.map(sensor => {
        const numeric = clampWeight(sensor.weight, null);
        return numeric === null ? 0 : numeric;
      });
      const total = weights.reduce((sum, value) => sum + value, 0);
      const average = weights.length ? total / weights.length : 0;
      const median = computeMedian(weights);
      return { median, average, total, count: weights.length };
    }

    function formatWeightPercent(value) {
      const numeric = clampWeight(value, null);
      if (numeric === null) return '--';
      return `${Math.round(numeric * 100)}%`;
    }

    function renderSensorWeightPreview(device) {
      if (!device) return '';
      const stats = computeZoneWeightStats(device);
      const defaultWeight = stats.count > 0 ? 1 / stats.count : 0;
      const weight = clampWeight(device.weight, defaultWeight) ?? defaultWeight;
      const weightPercent = formatWeightPercent(weight);
      const medianPercent = formatWeightPercent(stats.median);
      let deltaText = '';
      if (stats.count > 0) {
        const deltaPercent = Math.round((weight - stats.median) * 100);
        if (deltaPercent > 0) {
          deltaText = `(+${deltaPercent}%)`;
        } else if (deltaPercent < 0) {
          deltaText = `(${deltaPercent}%)`;
        }
      }
      const zoneShare = stats.total > 0 ? `${formatNumber((weight / stats.total) * 100, 1)}% share` : '';
      const parts = [
        `${weightPercent} weight`,
        `Median ${medianPercent}${deltaText ? ` ${deltaText}` : ''}`,
        zoneShare
      ].filter(Boolean);
      return parts.join(' • ');
    }

    function createOption(id, name, prefix) {
      const trimmedName = typeof name === 'string' ? name.trim() : '';
      const trimmedId = typeof id === 'string' ? id.trim() : '';
      const displayName = trimmedName || trimmedId;
      if (!displayName) return null;
      let value = trimmedId;
      if (!value) {
        const slug = slugify(displayName);
        value = slug ? `${prefix}-${slug}` : nextFallbackValue(prefix);
      }
      return {
        id: trimmedId || null,
        name: displayName,
        value
      };
    }

    function normalizeZoneOption(zone, index = 0) {
      if (!zone) return null;
      if (typeof zone === 'string') {
        return createOption(null, zone, 'zone');
      }
      if (typeof zone === 'object') {
        const source = zone;
        const id = source.id || source.zoneId || source.zone_id || source.zone || source.identifier || null;
        const name = source.name || source.displayName || source.label || source.zone || source.location || id || `Zone ${index + 1}`;
        return createOption(id, name, 'zone');
      }
      return null;
    }

    function normalizeRoomOption(room, index = 0) {
      if (!room) return null;
      if (typeof room === 'string') {
        return createOption(null, room, 'room');
      }
      if (typeof room === 'object') {
        const source = room;
        const id = source.id || source.roomId || source.room_id || source.identifier || null;
        const name = source.name || source.label || source.title || source.roomName || source.location || id || `Room ${index + 1}`;
        return createOption(id, name, 'room');
      }
      return null;
    }

    function normalizeLevelOption(level, index = 0) {
      if (!level) return null;
      if (typeof level === 'string' || typeof level === 'number') {
        return createOption(null, String(level), 'level');
      }
      if (typeof level === 'object') {
        const source = level;
        const rawValue = source.value || source.slug || source.code || null;
        const id = source.id || source.levelId || source.level || rawValue || null;
        const name =
          source.name ||
          source.label ||
          source.levelName ||
          source.level ||
          id ||
          `Level ${index + 1}`;
        const option = createOption(id, name, 'level');
        if (option && rawValue) {
          option.value = String(rawValue).trim();
        }
        return option;
      }
      return null;
    }

    function normalizeSideOption(side, index = 0) {
      if (!side) return null;
      if (typeof side === 'string' || typeof side === 'number') {
        return createOption(null, String(side), 'side');
      }
      if (typeof side === 'object') {
        const source = side;
        const rawValue = source.value || source.slug || source.code || null;
        const id = source.id || source.sideId || source.side || rawValue || null;
        const name =
          source.name ||
          source.label ||
          source.sideName ||
          source.side ||
          id ||
          `Side ${index + 1}`;
        const option = createOption(id, name, 'side');
        if (option && rawValue) {
          option.value = String(rawValue).trim();
        }
        return option;
      }
      return null;
    }

    function dedupeAndSortOptions(options) {
      const map = new Map();
      (options || []).forEach(option => {
        if (!option || !option.value) return;
        if (!map.has(option.value)) {
          map.set(option.value, option);
        } else {
          const existing = map.get(option.value);
          if (!existing.name && option.name) {
            map.set(option.value, option);
          }
        }
      });
      return Array.from(map.values()).sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
      );
    }

    function findOption(list, value) {
      if (!value) return null;
      const normalized = String(value).trim();
      if (!normalized) return null;
      return (list || []).find(
        option =>
          option.value === normalized ||
          option.id === normalized ||
          option.name === normalized
      ) || null;
    }

    function setBaseZoneOptions(options, { lock = false, merge = false } = {}) {
      const normalized = dedupeAndSortOptions(options || []);
      if (merge && baseZoneOptions.length > 0) {
        baseZoneOptions = dedupeAndSortOptions([...baseZoneOptions, ...normalized]);
      } else if (zoneOptionsLocked && !lock) {
        if (merge) {
          baseZoneOptions = dedupeAndSortOptions([...baseZoneOptions, ...normalized]);
        } else if (baseZoneOptions.length === 0) {
          baseZoneOptions = normalized;
        }
      } else {
        baseZoneOptions = normalized;
      }
      if (lock && normalized.length > 0) {
        zoneOptionsLocked = true;
      }
      rebuildZoneOptions();
    }

    function setBaseRoomOptions(options) {
      baseRoomOptions = dedupeAndSortOptions(options || []);
      rebuildRoomOptions();
    }

    function setBaseLevelOptions(options) {
      baseLevelOptions = dedupeAndSortOptions(options || []);
      rebuildLevelOptions();
    }

    function setBaseSideOptions(options) {
      baseSideOptions = dedupeAndSortOptions(options || []);
      rebuildSideOptions();
    }

    function extractZoneOptionsFromMetadata(meta) {
      if (!meta || typeof meta !== 'object') return [];
      const details = meta.details || {};
      const candidates = [
        createOption(details.zoneId || details.zoneSlug || null, details.zoneName || details.zone, 'zone'),
        createOption(meta.zoneId || meta.zoneSlug || null, meta.zoneName || meta.zone, 'zone'),
        createOption(null, meta.zone, 'zone')
      ];
      return candidates.filter(Boolean);
    }

    function extractRoomOptionsFromMetadata(meta) {
      if (!meta || typeof meta !== 'object') return [];
      const details = meta.details || {};
      const assigned = meta.assignedEquipment || {};
      const candidates = [
        createOption(details.roomId || details.roomSlug || null, details.roomName || details.room || details.location, 'room'),
        createOption(meta.roomId || meta.roomSlug || null, meta.roomName || meta.room || meta.location, 'room'),
        createOption(assigned.roomId || null, assigned.roomName || assigned.room || null, 'room')
      ];
      const enriched = candidates
        .filter(Boolean)
        .map(option => {
          if (option && option.id && !option.name) {
            const match = findOption(baseRoomOptions, option.id);
            if (match) {
              return createOption(match.id, match.name, 'room');
            }
          }
          return option;
        });
      return enriched.filter(Boolean);
    }

    function rebuildZoneOptions() {
      const combined = [...baseZoneOptions];
      deviceMetadataMap.forEach(meta => {
        combined.push(...extractZoneOptionsFromMetadata(meta));
      });
      availableZones = dedupeAndSortOptions(combined);
    }

    function rebuildRoomOptions() {
      const combined = [...baseRoomOptions];
      deviceMetadataMap.forEach(meta => {
        combined.push(...extractRoomOptionsFromMetadata(meta));
      });
      availableRooms = dedupeAndSortOptions(combined);
    }

    function rebuildLevelOptions() {
      const combined = [...baseLevelOptions];
      devices.forEach(device => {
        const level = device?.placement?.level;
        if (level) {
          const option = normalizeLevelOption(level);
          if (option) combined.push(option);
        }
      });
      deviceMetadataMap.forEach(meta => {
        const details = meta?.details || {};
        if (details.level || details.rackLevel || details.tier || details.shelf) {
          combined.push(
            ...[
              details.level,
              details.rackLevel,
              details.tier,
              details.shelf
            ]
              .filter(Boolean)
              .map(value => normalizeLevelOption(value))
              .filter(Boolean)
          );
        }
      });
      availableLevels = dedupeAndSortOptions(combined);
    }

    function rebuildSideOptions() {
      const combined = [...baseSideOptions];
      devices.forEach(device => {
        const side = device?.placement?.side;
        if (side) {
          const option = normalizeSideOption(side);
          if (option) combined.push(option);
        }
      });
      deviceMetadataMap.forEach(meta => {
        const details = meta?.details || {};
        if (details.side || details.orientation || details.aisle) {
          combined.push(
            ...[
              details.side,
              details.orientation,
              details.aisle
            ]
              .filter(Boolean)
              .map(value => normalizeSideOption(value))
              .filter(Boolean)
          );
        }
      });
      availableSides = dedupeAndSortOptions(combined);
    }

    function findZoneOption(value) {
      return findOption(availableZones, value) || findOption(baseZoneOptions, value);
    }

    function findRoomOption(value) {
      return findOption(availableRooms, value) || findOption(baseRoomOptions, value);
    }

    function findLevelOption(value) {
      return findOption(availableLevels, value) || findOption(baseLevelOptions, value);
    }

    function findSideOption(value) {
      return findOption(availableSides, value) || findOption(baseSideOptions, value);
    }

    function normalizeGroupKind(value) {
      if (!value && value !== 0) return null;
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) return null;
      if (normalized === 'light' || normalized === 'lighting' || normalized === 'lights') return 'light';
      if (
        normalized === 'equip' ||
        normalized === 'equipment' ||
        normalized === 'environment' ||
        normalized === 'env' ||
        normalized === 'climate'
      ) {
        return 'equip';
      }
      if (normalized.includes('light')) return 'light';
      if (normalized.includes('equip') || normalized.includes('env') || normalized.includes('climate')) return 'equip';
      return null;
    }

    function normalizeGroupEntry(entry, index = 0) {
      if (!entry) return null;
      if (typeof entry === 'string') {
        return null;
      }
      if (typeof entry !== 'object') {
        return null;
      }
      const source = entry;
      const id = firstString(source.id, source.groupId, source.group_id, source.uuid, source.slug, source.value);
      const value = firstString(source.value, id, `group-${index + 1}`);
      const name = firstString(
        source.name,
        source.label,
        source.title,
        source.displayName,
        source.groupName,
        source.group,
        value,
        `Group ${index + 1}`
      );
      const kind = normalizeGroupKind(source.kind || source.type || source.groupType || source.category || source.domain);
      if (!kind) return null;
      const zoneId = firstString(source.zoneId, source.zoneSlug, source.zone_id, source.zone);
      const zoneName = firstString(source.zoneName, source.zoneLabel, source.zoneTitle, source.zone);
      const roomId = firstString(source.roomId, source.roomSlug, source.room_id, source.locationId, source.room);
      const roomName = firstString(source.roomName, source.roomLabel, source.roomTitle, source.locationName, source.location);

      return {
        id: id || value,
        value: value || id,
        name,
        kind,
        zoneId,
        zoneName,
        roomId,
        roomName,
        raw: { ...source }
      };
    }

    function ingestGroupCatalog(list = []) {
      const map = new Map();
      (list || []).forEach((entry, index) => {
        const normalized = normalizeGroupEntry(entry, index);
        if (!normalized) return;
        const key = String(normalized.id || normalized.value).toLowerCase();
        if (!map.has(key)) {
          map.set(key, normalized);
        }
      });
      groupCatalog = Array.from(map.values()).sort((a, b) => a.name.localeCompare(b.name));
      groupCatalogLoaded = true;
    }

    function findGroupById(groupId) {
      if (!groupId) return null;
      const normalized = String(groupId).trim().toLowerCase();
      if (!normalized) return null;
      return (
        groupCatalog.find(group =>
          equalsIgnoreCase(group.id, normalized) || equalsIgnoreCase(group.value, normalized)
        ) || null
      );
    }

    async function fetchGroupCatalog() {
      if (groupCatalogLoaded && groupCatalog.length > 0) {
        return groupCatalog;
      }

      const collected = [];
      const sources = ['/groups/catalog', '/groups', '/data/groups.json'];

      for (const source of sources) {
        try {
          const response = await fetch(source);
          if (!response.ok) continue;
          const data = await response.json();
          if (!data) continue;
          if (Array.isArray(data)) {
            collected.push(...data);
          } else if (Array.isArray(data.groups)) {
            collected.push(...data.groups);
          } else {
            const lightGroups = Array.isArray(data.lightGroups) ? data.lightGroups : [];
            const equipGroups = Array.isArray(data.equipGroups) ? data.equipGroups : [];
            const environmentGroups = Array.isArray(data.environmentGroups) ? data.environmentGroups : [];
            collected.push(...lightGroups, ...equipGroups, ...environmentGroups);
          }
        } catch (error) {
          console.warn(`Failed to load groups from ${source}:`, error);
        }
      }

      if (collected.length > 0) {
        ingestGroupCatalog(collected);
      } else {
        groupCatalogLoaded = true;
      }

      return groupCatalog;
    }

    function valuesForPlacementEntry(entry) {
      if (!entry) return [];
      if (typeof entry === 'string') {
        return [entry];
      }
      if (typeof entry === 'object') {
        return [entry.value, entry.id, entry.name].filter(Boolean);
      }
      return [];
    }

    function getDevicePlacementValues(device) {
      const placement = device?.placement || {};
      const zoneValues = [
        device?.zoneId,
        device?.zoneName,
        ...(valuesForPlacementEntry(placement.zone) || []),
        device?.lastReading?.zone,
        device?.lastReading?.name
      ]
        .filter(Boolean)
        .map(value => String(value));
      const roomValues = [
        device?.farmLocationId,
        device?.farmLocation,
        ...(valuesForPlacementEntry(placement.room) || []),
        device?.lastReading?.location
      ]
        .filter(Boolean)
        .map(value => String(value));
      return { zoneValues, roomValues };
    }

    function filterGroupsForDevice(device, kind) {
      if (!device || !kind) return [];
      const normalizedKind = normalizeGroupKind(kind);
      if (!normalizedKind) return [];
      const { zoneValues, roomValues } = getDevicePlacementValues(device);

      const matches = groupCatalog.filter(group => {
        if (group.kind !== normalizedKind) return false;
        const zoneMatch =
          !group.zoneId ||
          matchesAny(group.zoneId, zoneValues) ||
          matchesAny(group.zoneName, zoneValues);
        const roomMatch =
          !group.roomId ||
          matchesAny(group.roomId, roomValues) ||
          matchesAny(group.roomName, roomValues);
        return zoneMatch && roomMatch;
      });

      if (matches.length > 0) {
        return matches;
      }

      return groupCatalog.filter(group => group.kind === normalizedKind);
    }

    function buildGroupOptionsForDevice(device, kind) {
      return filterGroupsForDevice(device, kind).map(group => ({
        id: group.id,
        name: group.name,
        value: group.value
      }));
    }

    function getCanonicalDeviceId(source) {
      if (!source || typeof source !== 'object') return '';
      const candidate =
        source.device_id ??
        source.deviceId ??
        source.id ??
        source.uuid ??
        source.deviceID ??
        source.macAddress ??
        '';
      return typeof candidate === 'string'
        ? candidate.trim()
        : String(candidate || '').trim();
    }

    function normalizeMetadata(raw) {
      if (!raw || typeof raw !== 'object') return null;
      return { ...raw };
    }

    function storeDeviceMetadata(raw) {
      const normalized = normalizeMetadata(raw);
      if (!normalized) return null;
      const id = getCanonicalDeviceId(normalized);
      if (!id) return null;
      normalized.device_id = id;
      deviceMetadataMap.set(id.toLowerCase(), normalized);
      return normalized;
    }

    function getDeviceMetadata(deviceId) {
      const key =
        typeof deviceId === 'string'
          ? deviceId.trim()
          : String(deviceId || '').trim();
      if (!key) return null;
      return deviceMetadataMap.get(key.toLowerCase()) || null;
    }

    function getZoneSelection(metadata, device) {
      const candidates = [];
      if (metadata && typeof metadata === 'object') {
        const details = metadata.details || {};
        candidates.push({ value: details.zoneSlug, label: details.zoneName || details.zone });
        candidates.push({ value: details.zoneId, label: details.zoneName || details.zone });
        candidates.push({ value: metadata.zoneSlug, label: metadata.zoneName });
        candidates.push({ value: metadata.zoneId, label: metadata.zoneName });
        candidates.push({ value: metadata.zone, label: metadata.zone });
      }
      if (device && typeof device === 'object') {
        candidates.push({ value: device.zoneId, label: device.zoneName });
        candidates.push({ value: device.zone, label: device.zoneName || device.zone });
      }
      for (const candidate of candidates) {
        if (!candidate) continue;
        const { value, label } = candidate;
        if (value) {
          const option = findZoneOption(value) || findZoneOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
          return {
            value: String(value).trim(),
            label: label ? String(label).trim() : String(value).trim()
          };
        }
        if (label) {
          const option = findZoneOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
        }
      }
      return { value: '', label: '' };
    }

    function getRoomSelection(metadata, device) {
      const candidates = [];
      if (metadata && typeof metadata === 'object') {
        const details = metadata.details || {};
        const assigned = metadata.assignedEquipment || {};
        candidates.push({ value: details.roomSlug, label: details.roomName || details.room || details.location });
        candidates.push({ value: details.roomId, label: details.roomName || details.room || details.location });
        candidates.push({ value: metadata.roomSlug, label: metadata.roomName || metadata.room || metadata.location });
        candidates.push({ value: metadata.roomId, label: metadata.roomName || metadata.room || metadata.location });
        candidates.push({ value: assigned.roomId, label: assigned.roomName || assigned.room });
        candidates.push({ value: metadata.location, label: metadata.location });
      }
      if (device && typeof device === 'object') {
        candidates.push({ value: device.farmLocationId, label: device.farmLocation });
        candidates.push({ value: device.farmLocation, label: device.farmLocation });
      }
      for (const candidate of candidates) {
        if (!candidate) continue;
        const { value, label } = candidate;
        if (value) {
          const option = findRoomOption(value) || findRoomOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
          return {
            value: String(value).trim(),
            label: label ? String(label).trim() : String(value).trim()
          };
        }
        if (label) {
          const option = findRoomOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
        }
      }
      return { value: '', label: '' };
    }

    function computeVPD(tempC, humidityPercent) {
      const temp = Number(tempC);
      const rh = Number(humidityPercent);
      if (!Number.isFinite(temp) || !Number.isFinite(rh)) return null;
      const clampedRh = Math.min(Math.max(rh, 0), 100);
      const saturationVaporPressure = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));
      const deficit = saturationVaporPressure * (1 - clampedRh / 100);
      const rounded = Math.round(deficit * 100) / 100;
      return Number.isFinite(rounded) ? rounded : null;
    }

    function formatNumber(value, decimals = 1) {
      const num = Number(value);
      if (!Number.isFinite(num)) return String(value);
      const fixed = num.toFixed(decimals);
      return fixed.replace(/\.0+$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
    }

    function formatRelativeTime(timestamp) {
      if (!timestamp) return 'Never';
      const date = new Date(timestamp);
      if (Number.isNaN(date.getTime())) {
        return String(timestamp);
      }
      const diffMs = Date.now() - date.getTime();
      if (diffMs < 0) {
        return date.toLocaleString();
      }
      const seconds = Math.floor(diffMs / 1000);
      if (seconds < 60) {
        return 'Just now';
      }
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) {
        return `${minutes} min${minutes === 1 ? '' : 's'} ago`;
      }
      const hours = Math.floor(minutes / 60);
      if (hours < 24) {
        return `${hours} hr${hours === 1 ? '' : 's'} ago`;
      }
      const days = Math.floor(hours / 24);
      if (days <= 7) {
        return `${days} day${days === 1 ? '' : 's'} ago`;
      }
      return date.toLocaleString();
    }

    function formatSignalLabel(signal) {
      const numeric = toNumeric(signal);
      if (numeric === null) return '--';
      return `${numeric} dBm`;
    }

    function getPowerState(reading = {}) {
      if (!reading || typeof reading !== 'object') return null;
      const candidates = [
        reading.power,
        reading.powerState,
        reading.powerStatus,
        reading.switch,
        reading.switchStatus,
        reading.status,
        reading.state
      ];
      for (const candidate of candidates) {
        if (candidate === undefined || candidate === null) continue;
        if (typeof candidate === 'string') {
          const normalized = candidate.trim().toLowerCase();
          if (normalized === 'on' || normalized === 'open' || normalized === 'true') return 'on';
          if (normalized === 'off' || normalized === 'closed' || normalized === 'false') return 'off';
        } else if (typeof candidate === 'boolean') {
          return candidate ? 'on' : 'off';
        } else if (typeof candidate === 'number') {
          if (candidate === 1) return 'on';
          if (candidate === 0) return 'off';
          return candidate > 0 ? 'on' : 'off';
        }
      }
      return null;
    }

    function getBatteryTone(level) {
      const numeric = Number(level);
      if (!Number.isFinite(numeric)) return 'neutral';
      if (numeric >= 70) return 'positive';
      if (numeric >= 30) return 'warning';
      return 'critical';
    }

    function formatBatteryLabel(level) {
      const numeric = Number(level);
      if (!Number.isFinite(numeric)) return 'Battery';
      if (numeric >= 70) return 'Battery Good';
      if (numeric >= 30) return 'Battery Low';
      return 'Battery Critical';
    }

    function isPlugDevice(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      return type.includes('plug') || type.includes('outlet') || type.includes('switch');
    }

    function isSensorDevice(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      return (
        type.includes('sensor') ||
        type.includes('meter') ||
        type.includes('monitor') ||
        type.includes('woiosensor')
      );
    }

    function enrichReading(reading) {
      if (!reading || typeof reading !== 'object') return reading;
      const enriched = { ...reading };
      if (
        enriched.vpd === undefined &&
        typeof enriched.temperature === 'number' &&
        typeof enriched.humidity === 'number'
      ) {
        const computed = computeVPD(enriched.temperature, enriched.humidity);
        if (computed !== null) {
          enriched.vpd = computed;
        }
      }
      if (enriched.weight !== undefined && enriched.wattage === undefined) {
        enriched.wattage = enriched.weight;
      }
      return enriched;
    }

    function enrichDeviceReading(device) {
      if (device && device.lastReading) {
        device.lastReading = enrichReading(device.lastReading);
      }
    }

    function applyMetadataToDevice(device, metadataOverride, options = {}) {
      if (!device) return;
      const metadata = metadataOverride || getDeviceMetadata(getCanonicalDeviceId(device));
      enrichDeviceReading(device);
      if (metadata) {
        const nameFromMeta =
          metadata.name ||
          metadata.deviceName ||
          (metadata.details && (metadata.details.displayName || metadata.details.name));
        if (nameFromMeta) {
          device.displayName = nameFromMeta;
        }
        const zoneSelection = getZoneSelection(metadata, device);
        device.zoneId = zoneSelection.value || '';
        device.zoneName = zoneSelection.label || '';
        const roomSelection = getRoomSelection(metadata, device);
        device.farmLocationId = roomSelection.value || '';
        device.farmLocation = roomSelection.label || '';
        const metadataDetails = metadata.details || {};
        const managed =
          metadataDetails.managedEquipment ??
          metadata.managedEquipment ??
          device.managedEquipment ??
          '';
        device.managedEquipment = managed || '';
        const assignedGroups = metadata.assignedGroups || metadata.groups || {};
        const lightGroupId = firstString(
          assignedGroups.lightGroupId,
          assignedGroups.lightGroup,
          assignedGroups.light,
          metadata.lightGroupId,
          metadata.lightGroup,
          metadata.lightingGroupId,
          metadata.lightingGroup,
          metadataDetails.lightGroupId,
          metadataDetails.lightGroup,
          metadataDetails.lightingGroupId,
          metadataDetails.lightingGroup,
          device.groupAssignments?.light
        );
        const equipGroupId = firstString(
          assignedGroups.equipGroupId,
          assignedGroups.equipmentGroupId,
          assignedGroups.environmentGroupId,
          assignedGroups.envGroupId,
          assignedGroups.equip,
          metadata.equipGroupId,
          metadata.equipmentGroupId,
          metadata.environmentGroupId,
          metadata.envGroupId,
          metadataDetails.equipGroupId,
          metadataDetails.equipmentGroupId,
          metadataDetails.environmentGroupId,
          metadataDetails.envGroupId,
          device.groupAssignments?.equip
        );
        const lightGroupName = firstString(
          assignedGroups.lightGroupName,
          assignedGroups.lightingGroupName,
          metadata.lightGroupName,
          metadata.lightingGroupName,
          metadataDetails.lightGroupName,
          metadataDetails.lightingGroupName
        );
        const equipGroupName = firstString(
          assignedGroups.equipGroupName,
          assignedGroups.equipmentGroupName,
          assignedGroups.environmentGroupName,
          assignedGroups.envGroupName,
          metadata.equipGroupName,
          metadata.equipmentGroupName,
          metadata.environmentGroupName,
          metadata.envGroupName,
          metadataDetails.equipGroupName,
          metadataDetails.equipmentGroupName,
          metadataDetails.environmentGroupName,
          metadataDetails.envGroupName
        );
        const lightGroup = lightGroupId ? findGroupById(lightGroupId) : null;
        const equipGroup = equipGroupId ? findGroupById(equipGroupId) : null;
        device.groupAssignments = {
          light: lightGroupId || '',
          equip: equipGroupId || ''
        };
        device.groupAssignmentLabels = {
          light: firstString(lightGroupName, lightGroup?.name),
          equip: firstString(equipGroupName, equipGroup?.name)
        };
      } else {
        if (!device.displayName) {
          device.displayName = device.deviceName || device.device_id || device.deviceId;
        }
        device.groupAssignments = device.groupAssignments || { light: '', equip: '' };
        device.groupAssignmentLabels = device.groupAssignmentLabels || { light: '', equip: '' };
      }
      syncDeviceCardSchema(device, metadata);
      if (!options.skipRecalculate) {
        recalculateSensorWeights();
      }
    }

    function applyMetadataToAllDevices() {
      devices.forEach(device => {
        applyMetadataToDevice(device, undefined, { skipRecalculate: true });
      });
      recalculateSensorWeights();
      rebuildLevelOptions();
      rebuildSideOptions();
    }

    function renderSelectOptions(options, selectedValue, selectedLabel, placeholder) {
      const normalizedSelected = selectedValue ? String(selectedValue).trim() : '';
      const html = [
        `<option value=""${normalizedSelected ? '' : ' selected'}>${escapeHtml(placeholder)}</option>`
      ];
      let hasSelected = false;
      (options || []).forEach(option => {
        if (!option || !option.value) return;
        const isSelected = normalizedSelected && option.value === normalizedSelected;
        if (isSelected) hasSelected = true;
        html.push(
          `<option value="${escapeAttribute(option.value)}"${isSelected ? ' selected' : ''}>${escapeHtml(option.name)}</option>`
        );
      });
      if (normalizedSelected && !hasSelected) {
        html.push(
          `<option value="${escapeAttribute(normalizedSelected)}" selected>${escapeHtml(selectedLabel || normalizedSelected)}</option>`
        );
      }
      return html.join('');
    }

    function createDeviceSummary(device, reading) {
      if (!device || !reading || typeof reading !== 'object') return '';
      const type = String(device.deviceType || '').toLowerCase();
      const items = [];

      if (isPlugDevice(type)) {
        const state = getPowerState(reading);
        if (state) {
          items.push({
            label: 'Status',
            value: state.toUpperCase(),
            tone: state === 'on' ? 'positive' : 'critical'
          });
        }
        if (reading.wattage !== undefined) {
          items.push({ label: 'Wattage', value: `${formatNumber(reading.wattage, 1)} W` });
        }
        if (reading.voltage !== undefined) {
          items.push({ label: 'Voltage', value: `${formatNumber(reading.voltage, 1)} V` });
        }
        if (reading.electricCurrent !== undefined) {
          items.push({ label: 'Current', value: `${formatNumber(reading.electricCurrent, 2)} A` });
        }
      } else if (isSensorDevice(type)) {
        if (reading.temperature !== undefined) {
          items.push({ label: 'Temperature', value: `${formatNumber(reading.temperature, 1)} °C` });
        }
        if (reading.humidity !== undefined) {
          items.push({ label: 'Humidity', value: `${formatNumber(reading.humidity, 1)} %` });
        }
        const vpdValue = reading.vpd ?? computeVPD(reading.temperature, reading.humidity);
        if (vpdValue !== null && vpdValue !== undefined) {
          items.push({ label: 'VPD', value: `${formatNumber(vpdValue, 2)} kPa` });
        }
        if (reading.battery !== undefined) {
          items.push({
            label: 'Battery',
            value: `${formatNumber(reading.battery, 0)}%`,
            tone: getBatteryTone(reading.battery)
          });
        }
      }

      if (!items.length) return '';

      const chips = items
        .map(item => {
          const toneClass = item.tone ? ` tone-${item.tone}` : '';
          return `
          <div class="device-summary-item${toneClass}">
            <div class="device-summary-value">${escapeHtml(item.value)}</div>
            <div class="device-summary-label">${escapeHtml(item.label)}</div>
          </div>
        `;
        })
        .join('');
      return `<div class="device-summary">${chips}</div>`;
    }

    async function fetchEnvironmentData() {
      try {
        // Try multiple data sources for SwitchBot data
        const dataSources = [
          '/env',  // Local environment endpoint
          '/api/azure/telemetry',  // Azure telemetry API
          '/api/azure/iot-hub'     // Azure IoT Hub data
        ];
        
        for (const source of dataSources) {
          try {
            const response = await fetch(source);
            if (response.ok) {
              const data = await response.json();
              console.log(`Successfully fetched data from ${source}`);
              return data.zones || data.devices || data || [];
            }
          } catch (error) {
            console.warn(`Failed to fetch from ${source}:`, error.message);
          }
        }
        
        throw new Error('No data sources available');
      } catch (error) {
        console.error('Environment API Error:', error);
        throw error;
      }
    }

    async function ensureEnvironmentData(force = false) {
      const hadData = Array.isArray(environmentData) && environmentData.length > 0;
      if (!force && hadData) {
        return environmentData;
      }

      try {
        const data = await fetchEnvironmentData();
        const normalized = Array.isArray(data) ? data : [];
        environmentData = normalized;
        const zoneOptions = normalized
          .map((zone, index) => normalizeZoneOption(zone, index))
          .filter(Boolean);
        setBaseZoneOptions(zoneOptions, { merge: true });
        return environmentData;
      } catch (error) {
        if (!hadData) {
          environmentData = [];
          setBaseZoneOptions([]);
        }
        throw error;
      }
    }

    function collectFarmLayoutEntities(payload, rooms = [], zones = [], levels = [], sides = []) {
      if (!payload) return;
      if (Array.isArray(payload)) {
        payload.forEach(item => collectFarmLayoutEntities(item, rooms, zones, levels, sides));
        return;
      }
      if (typeof payload !== 'object') {
        return;
      }

      const roomCandidates = [];
      if (Array.isArray(payload.rooms)) roomCandidates.push(...payload.rooms);
      else if (payload.rooms && typeof payload.rooms === 'object') roomCandidates.push(payload.rooms);
      if (typeof payload.room === 'string' || typeof payload.room === 'object') {
        roomCandidates.push(payload.room);
      }

      roomCandidates.forEach(room => {
        const roomOption = normalizeRoomOption(room, rooms.length);
        if (roomOption) {
          rooms.push(roomOption);
        }
        if (room && typeof room === 'object') {
          const nestedZones = Array.isArray(room.zones) ? room.zones : [];
          nestedZones.forEach(zone => {
            const zoneOption = normalizeZoneOption(zone, zones.length);
            if (zoneOption) zones.push(zoneOption);
          });
          const levelCandidates = [
            room.level,
            room.rackLevel,
            room.tier,
            room.shelf
          ].filter(Boolean);
          levelCandidates.forEach(level => {
            const option = normalizeLevelOption(level, levels.length);
            if (option) levels.push(option);
          });
          const sideCandidates = [room.side, room.orientation, room.aisle].filter(Boolean);
          sideCandidates.forEach(side => {
            const option = normalizeSideOption(side, sides.length);
            if (option) sides.push(option);
          });
          if (Array.isArray(room.children)) {
            room.children.forEach(child => collectFarmLayoutEntities(child, rooms, zones, levels, sides));
          }
        }
      });

      const zoneCandidates = [];
      if (Array.isArray(payload.zones)) zoneCandidates.push(...payload.zones);
      else if (payload.zones && typeof payload.zones === 'object') zoneCandidates.push(payload.zones);
      if (typeof payload.zone === 'string' || typeof payload.zone === 'object') {
        zoneCandidates.push(payload.zone);
      }

      zoneCandidates.forEach(zone => {
        const zoneOption = normalizeZoneOption(zone, zones.length);
        if (zoneOption) {
          zones.push(zoneOption);
        }
        if (zone && typeof zone === 'object') {
          const levelCandidates = [zone.level, zone.tier, zone.shelf].filter(Boolean);
          levelCandidates.forEach(level => {
            const option = normalizeLevelOption(level, levels.length);
            if (option) levels.push(option);
          });
          const sideCandidates = [zone.side, zone.orientation, zone.aisle].filter(Boolean);
          sideCandidates.forEach(side => {
            const option = normalizeSideOption(side, sides.length);
            if (option) sides.push(option);
          });
        }
      });

      const nestedLayouts = [payload.layout, payload.farm, payload.greenhouse, payload.facility]
        .filter(section => section && typeof section === 'object');
      nestedLayouts.forEach(section => collectFarmLayoutEntities(section, rooms, zones, levels, sides));
    }

    async function fetchFarmLayout() {
      const rooms = [];
      const zones = [];
      const levels = [];
      const sides = [];
      const sources = ['/farm', '/data/farm.json', '/data/rooms.json'];

      for (const source of sources) {
        try {
          const response = await fetch(source);
          if (!response.ok) continue;
          const data = await response.json();
          if (!data) continue;
          if (source.endsWith('rooms.json')) {
            const rawRooms = Array.isArray(data?.rooms) ? data.rooms : [];
            rawRooms.forEach(room => {
              const option = normalizeRoomOption(room, rooms.length);
              if (option) rooms.push(option);
              if (room && typeof room === 'object') {
                const levelOption = normalizeLevelOption(room.level || room.tier || room.shelf, levels.length);
                if (levelOption) levels.push(levelOption);
                const sideOption = normalizeSideOption(room.side || room.orientation || room.aisle, sides.length);
                if (sideOption) sides.push(sideOption);
              }
            });
          } else if (Array.isArray(data)) {
            data.forEach(entry => collectFarmLayoutEntities(entry, rooms, zones, levels, sides));
          } else {
            collectFarmLayoutEntities(data, rooms, zones, levels, sides);
          }
        } catch (error) {
          console.warn(`Failed to load farm layout from ${source}:`, error);
        }
      }

      if (rooms.length > 0) {
        setBaseRoomOptions(rooms);
      }
      if (zones.length > 0) {
        setBaseZoneOptions(zones, { lock: true });
      }
      if (levels.length > 0) {
        setBaseLevelOptions(levels);
      }
      if (sides.length > 0) {
        setBaseSideOptions(sides);
      }

      return { rooms, zones, levels, sides };
    }

    async function fetchDeviceMetadata() {
      try {
        const response = await fetch('/devices');
        if (!response.ok) {
          throw new Error(`Failed to load device metadata (${response.status})`);
        }
        const payload = await response.json();
        const list = Array.isArray(payload?.devices)
          ? payload.devices
          : Array.isArray(payload)
          ? payload
          : [];

        deviceMetadataMap.clear();
        list.forEach(item => {
          storeDeviceMetadata(item);
        });
        rebuildZoneOptions();
        rebuildRoomOptions();
        deviceMetadataLoaded = true;
        return list;
      } catch (error) {
        console.warn('Failed to load device metadata:', error);
        deviceMetadataLoaded = false;
        return [];
      }
    }

    async function loadDeviceMetadataIfNeeded(force = false) {
      if (!force && deviceMetadataLoaded && deviceMetadataMap.size > 0) {
        return;
      }
      if (deviceMetadataPromise) {
        await deviceMetadataPromise;
        return;
      }
      deviceMetadataPromise = fetchDeviceMetadata().finally(() => {
        deviceMetadataPromise = null;
      });
      await deviceMetadataPromise;
    }

    async function loadReferenceData() {
      await Promise.all([
        ensureEnvironmentData().catch(error => {
          console.warn('Environment data unavailable:', error);
          return [];
        }),
        fetchFarmLayout().catch(error => {
          console.warn('Farm layout unavailable:', error);
          return { rooms: [], zones: [] };
        }),
        fetchGroupCatalog().catch(error => {
          console.warn('Group catalog unavailable:', error);
          return [];
        }),
        (async () => {
          try {
            await loadDeviceMetadataIfNeeded();
          } catch (error) {
            console.warn('Device metadata unavailable:', error);
          }
        })()
      ]);

      applyMetadataToAllDevices();
    }

    function sanitizeMetadataPayload(updates = {}) {
      const result = {};
      Object.entries(updates).forEach(([key, value]) => {
        if (value === undefined) {
          return;
        }
        if (value === '') {
          result[key] = null;
          return;
        }
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          result[key] = { ...value };
        } else {
          result[key] = value;
        }
      });
      return result;
    }

    async function fetchJson(url, options = {}) {
      const response = await fetch(url, options);
      const text = await response.text();
      let data = null;
      if (text) {
        try {
          data = JSON.parse(text);
        } catch (error) {
          data = null;
        }
      }
      return { response, data };
    }

    async function persistDeviceMetadata(device, updates = {}) {
      const deviceId = getCanonicalDeviceId(device);
      if (!deviceId) {
        throw new Error('Unable to determine device id for metadata update');
      }

      const payload = sanitizeMetadataPayload(updates);
      let result = await fetchJson(`/devices/${encodeURIComponent(deviceId)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (result.response.status === 404) {
        const createPayload = sanitizeMetadataPayload({
          id: deviceId,
          protocol: 'switchbot',
          category: device?.deviceType || 'SwitchBot Device',
          name: device?.displayName || device?.deviceName || deviceId,
          deviceName: device?.displayName || device?.deviceName || deviceId,
          manufacturer: 'SwitchBot',
          model: device?.deviceType || device?.deviceName || 'SwitchBot',
          ...updates
        });
        result = await fetchJson('/devices', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(createPayload)
        });
      }

      const { response, data } = result;
      if (!response.ok) {
        const message = (data && (data.error || data.message)) || `Request failed with status ${response.status}`;
        const error = new Error(message);
        error.status = response.status;
        error.data = data;
        throw error;
      }

      const saved = data && (data.device || data);
      if (saved) {
        const normalized = storeDeviceMetadata(saved);
        rebuildZoneOptions();
        rebuildRoomOptions();
        rebuildLevelOptions();
        rebuildSideOptions();
        return normalized || saved;
      }

      return saved;
    }

    async function fetchSwitchBotDevices() {
      try {
        // Fetch real SwitchBot devices from your farm
        const response = await fetch('/api/switchbot/devices');
        if (response.status === 429) {
          throw new Error('SwitchBot API rate limit reached. Please wait before making more requests.');
        }
        
        const data = await response.json();
        
        if (data.statusCode !== 100) {
          throw new Error(`SwitchBot API Error: ${data.message || 'Unknown error'}`);
        }
        
        return data.body?.deviceList || [];
      } catch (error) {
        console.error('SwitchBot API Error:', error);
        throw error;
      }
    }

    async function getDevices() {
      // Try to get live devices from SwitchBot API (with rate limiting protection)
      try {
        return await fetchSwitchBotDevices();
      } catch (error) {
        console.warn('SwitchBot API failed, using environment data:', error.message);
        // Fallback to environment data which includes SwitchBot readings
        const envData = await fetchEnvironmentData();
        return envData.filter(zone => zone.source === 'switchbot').map(zone => ({
          deviceId: zone.name || zone.zoneId,
          deviceName: zone.name || zone.zoneId,
          deviceType: 'SwitchBot Sensor',
          lastReading: zone
        }));
      }
    }

    async function getDeviceStatus(deviceId) {
      // For devices from environment data, return cached readings
      const envDevice = environmentData.find(zone => 
        (zone.name === deviceId || zone.zoneId === deviceId) && zone.source === 'switchbot'
      );
      
      if (envDevice) {
        return {
          statusCode: 100,
          body: {
            temperature: envDevice.temperature,
            humidity: envDevice.humidity,
            co2: envDevice.co2,
            battery: envDevice.battery,
            timestamp: envDevice.timestamp
          }
        };
      }
      
      // Try SwitchBot API as fallback (with rate limiting protection)
      try {
        const response = await fetch(`/api/switchbot/devices/${deviceId}/status`);
        if (response.status === 429) {
          throw new Error('Rate limit reached');
        }
        return await response.json();
      } catch (error) {
        console.warn(`Status fetch failed for ${deviceId}:`, error.message);
        return null;
      }
    }

    async function sendCommand(deviceId, command, parameter = '', commandType = 'command') {
      const response = await fetch(`/api/switchbot/devices/${deviceId}/commands`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          command,
          parameter,
          commandType
        })
      });

      const data = await response.json();
      if (!response.ok || data.statusCode !== 100) {
        const message = data?.message || `Command failed with status ${response.status}`;
        const error = new Error(message);
        error.data = data;
        error.status = response.status;
        throw error;
      }
      return data;
    }

    function showError(message) {
      const container = document.getElementById('errorContainer');
      container.innerHTML = `
        <div class="error-message">
          <strong>Error:</strong> ${message}
        </div>
      `;
    }

    function clearError() {
      document.getElementById('errorContainer').innerHTML = '';
    }

    function updateSyncStatus(status, isError = false) {
      const syncText = document.getElementById('syncText');
      const syncIndicator = document.getElementById('syncIndicator');
      
      syncText.textContent = status;
      
      if (isError) {
        syncIndicator.classList.add('error');
      } else {
        syncIndicator.classList.remove('error');
        syncIndicator.style.removeProperty('background');
        syncIndicator.style.removeProperty('animation');
      }
    }

    function formatReading(value, unit = '') {
      if (value === null || value === undefined) return '--';
      if (typeof value === 'boolean') return value ? 'Yes' : 'No';
      return `${value}${unit}`;
    }

    function createDeviceCard(device, status = null) {
      const isOnline = status && status.body;
      const readings = status?.body || {};
      
      const batteryLevel = readings.battery !== undefined ? readings.battery : null;
      const hasBattery = Number.isFinite(Number(batteryLevel));
      const batteryTone = hasBattery ? getBatteryTone(batteryLevel) : 'neutral';
      const batteryLabel = hasBattery ? formatBatteryLabel(batteryLevel) : 'External Power';
      const batteryDisplay = hasBattery ? `${formatNumber(batteryLevel, 0)}%` : 'Mains Power';
      const batteryMarkup = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryDisplay)}</span>`;

      // Enhanced device metadata
      const deviceModel = device.deviceType || 'Unknown';
      const firmwareVersion = readings.version?.BLE || device.version || '--';
      const lastUpdate = readings.lastUpdate || new Date().toISOString();
      const connectivity = readings.hubDeviceId ? 'Hub Connected' : 'Direct Connection';

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${deviceModel}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
              ${device.hubDeviceId ? `<p class="tiny" style="margin: 2px 0 0; color: #64748b;">Hub: ${device.hubDeviceId}</p>` : ''}
              ${firmwareVersion !== '--' ? `<p class="tiny" style="margin: 2px 0 0; color: #64748b;">FW: ${firmwareVersion}</p>` : ''}
            </div>
            <div style="text-align: right;">
              ${batteryMarkup}
              <div class="tiny" style="color: #64748b; margin-top: 2px;">${connectivity}</div>
              <button class="ghost tiny" onclick="refreshDevice('${device.deviceId}')" style="margin-top: 4px;">Refresh</button>
            </div>
          </div>
          
          ${createReadingsGrid(readings, device.deviceType)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last sync: ${new Date(lastUpdate).toLocaleTimeString()}
            </span>
            ${createDeviceControls(device)}
          </div>
        </div>
      `;
    }

    function createReadingsGrid(readings, deviceType) {
      const items = [];

      if (readings.temperature !== undefined) {
        items.push({ label: 'Temperature', value: formatReading(readings.temperature, '°C') });
      }

      if (readings.humidity !== undefined) {
        items.push({ label: 'Humidity', value: formatReading(readings.humidity, '%') });
      }

      if (readings.power !== undefined) {
        const state = typeof readings.power === 'string' ? readings.power.toUpperCase() : readings.power;
        const normalized = getPowerState(readings);
        const tone = normalized === 'on' ? 'positive' : normalized === 'off' ? 'warning' : '';
        items.push({ label: 'Power', value: normalized ? normalized.toUpperCase() : state, tone });
      }

      if (readings.voltage !== undefined) {
        items.push({ label: 'Voltage', value: formatReading(readings.voltage, 'V') });
      }

      if (readings.electricCurrent !== undefined) {
        items.push({ label: 'Current', value: formatReading(readings.electricCurrent, 'A') });
      }

      if (readings.electricityOfDay !== undefined) {
        items.push({ label: 'Daily Usage', value: formatReading(readings.electricityOfDay, 'kWh') });
      }

      if (readings.weight !== undefined) {
        items.push({ label: 'Power', value: formatReading(readings.weight, 'W') });
      }

      if (readings.moveDetected !== undefined) {
        items.push({ label: 'Motion', value: readings.moveDetected ? 'DETECTED' : 'NONE', tone: readings.moveDetected ? 'positive' : '' });
      }

      if (readings.brightness !== undefined) {
        items.push({ label: 'Light Level', value: formatReading(readings.brightness, '%') });
      }

      if (readings.lightLevel !== undefined) {
        items.push({ label: 'Illuminance', value: formatReading(readings.lightLevel, 'lux') });
      }

      if (readings.openState !== undefined) {
        items.push({ label: 'Door/Window', value: readings.openState === 'open' ? 'OPEN' : 'CLOSED' });
      }

      if (readings.version !== undefined && typeof readings.version === 'object' && readings.version.rssi) {
        items.push({ label: 'Signal', value: formatReading(readings.version.rssi, 'dBm') });
      }

      if (readings.version !== undefined && typeof readings.version === 'object' && readings.version.BLE) {
        items.push({ label: 'Firmware', value: readings.version.BLE });
      }

      if (items.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      }

      const chips = items
        .map(item => {
          const toneClass = item.tone ? ` tone-${item.tone}` : '';
          return `
          <div class="reading-item${toneClass}">
            <div class="reading-value">${escapeHtml(String(item.value))}</div>
            <div class="reading-label">${escapeHtml(item.label)}</div>
          </div>
        `;
        })
        .join('');
      return `<div class="reading-grid">${chips}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          }));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      const hasBatteryLevel = Number.isFinite(Number(reading?.battery));
      const batteryTone = hasBatteryLevel ? getBatteryTone(reading.battery) : 'neutral';
      const batteryValue = hasBatteryLevel ? `${formatNumber(reading.battery, 0)}%` : 'Mains Power';
      const batteryLabel = hasBatteryLevel ? formatBatteryLabel(reading.battery) : 'External Power';
      const batteryBadge = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryValue)}</span>`;

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${batteryBadge}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 8px;">Refresh</button>
            </div>
          </div>

          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '°C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO2</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          }));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      const hasBatteryLevel = Number.isFinite(Number(reading?.battery));
      const batteryTone = hasBatteryLevel ? getBatteryTone(reading.battery) : 'neutral';
      const batteryValue = hasBatteryLevel ? `${formatNumber(reading.battery, 0)}%` : 'Mains Power';
      const batteryLabel = hasBatteryLevel ? formatBatteryLabel(reading.battery) : 'External Power';
      const batteryBadge = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryValue)}</span>`;

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${batteryBadge}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 8px;">Refresh</button>
            </div>
          </div>

          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '°C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO2</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          }));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      const hasBatteryLevel = Number.isFinite(Number(reading?.battery));
      const batteryTone = hasBatteryLevel ? getBatteryTone(reading.battery) : 'neutral';
      const batteryValue = hasBatteryLevel ? `${formatNumber(reading.battery, 0)}%` : 'Mains Power';
      const batteryLabel = hasBatteryLevel ? formatBatteryLabel(reading.battery) : 'External Power';
      const batteryBadge = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryValue)}</span>`;

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${batteryBadge}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 8px;">Refresh</button>
            </div>
          </div>

          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '°C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO2</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          }));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      const hasBatteryLevel = Number.isFinite(Number(reading?.battery));
      const batteryTone = hasBatteryLevel ? getBatteryTone(reading.battery) : 'neutral';
      const batteryValue = hasBatteryLevel ? `${formatNumber(reading.battery, 0)}%` : 'Mains Power';
      const batteryLabel = hasBatteryLevel ? formatBatteryLabel(reading.battery) : 'External Power';
      const batteryBadge = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryValue)}</span>`;

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${batteryBadge}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 8px;">Refresh</button>
            </div>
          </div>

          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '°C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO2</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          }));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      const hasBatteryLevel = Number.isFinite(Number(reading?.battery));
      const batteryTone = hasBatteryLevel ? getBatteryTone(reading.battery) : 'neutral';
      const batteryValue = hasBatteryLevel ? `${formatNumber(reading.battery, 0)}%` : 'Mains Power';
      const batteryLabel = hasBatteryLevel ? formatBatteryLabel(reading.battery) : 'External Power';
      const batteryBadge = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryValue)}</span>`;

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${batteryBadge}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 8px;">Refresh</button>
            </div>
          </div>

          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '°C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO2</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          ));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      const hasBatteryLevel = Number.isFinite(Number(reading?.battery));
      const batteryTone = hasBatteryLevel ? getBatteryTone(reading.battery) : 'neutral';
      const batteryValue = hasBatteryLevel ? `${formatNumber(reading.battery, 0)}%` : 'Mains Power';
      const batteryLabel = hasBatteryLevel ? formatBatteryLabel(reading.battery) : 'External Power';
      const batteryBadge = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryValue)}</span>`;

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${batteryBadge}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 8px;">Refresh</button>
            </div>
          </div>

          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '°C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO2</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          ));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    // Rate limiting for API calls
    const lastApiCall = {};
    const API_RATE_LIMIT = 3000; // 3 seconds between calls per device

    async function refreshDeviceData(deviceId) {
      try {
        // Check rate limiting
        const now = Date.now();
        if (lastApiCall[deviceId] && (now - lastApiCall[deviceId]) < API_RATE_LIMIT) {
          showInfo(`⏳ Please wait ${Math.ceil((API_RATE_LIMIT - (now - lastApiCall[deviceId])) / 1000)} seconds before refreshing this device again`);
          return;
        }

        lastApiCall[deviceId] = now;
        const targetDevice = devices.find(d => d.deviceId === deviceId);
        const safeDeviceLabel = escapeHtml(targetDevice?.displayName || targetDevice?.deviceName || deviceId);
        showInfo(`Refreshing data for ${safeDeviceLabel}...`);

        // Call SwitchBot status API for individual device
        const response = await fetch(`/api/switchbot/devices/${deviceId}/status`);
        const data = await response.json();

        if (data.statusCode === 100) {
          // Update device with fresh data
          const device = targetDevice || devices.find(d => d.deviceId === deviceId);
          if (device) {
            const merged = {
              ...device.lastReading,
              ...data.body,
              lastUpdate: new Date().toISOString()
            };
            if (
              merged.vpd === undefined &&
              typeof merged.temperature === 'number' &&
              typeof merged.humidity === 'number'
            ) {
              const computedVpd = computeVPD(merged.temperature, merged.humidity);
              if (computedVpd !== null) {
                merged.vpd = computedVpd;
              }
            }
            if (merged.weight !== undefined && merged.wattage === undefined) {
              merged.wattage = merged.weight;
            }
            device.lastReading = enrichReading(merged);
            applyMetadataToDevice(device);
            renderDevicesFromAPI();
            const refreshedLabel = escapeHtml(device.displayName || device.deviceName || deviceId);
            showInfo(`Refreshed data for ${refreshedLabel}.`);
          }
        } else {
          throw new Error(data.message || 'Failed to get device status');
        }
      } catch (error) {
        console.error('Device refresh error:', error);
        showError(`Failed to refresh device data: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }

    async function controlDevice(deviceId, command) {
      try {
        const device = devices.find(d => d.deviceId === deviceId);
        const deviceName = device ? device.displayName || device.deviceName : deviceId;
        const safeCommand = escapeHtml(command);
        const safeDeviceName = escapeHtml(deviceName);

        showInfo(`Sending ${safeCommand} command to ${safeDeviceName}...`);

        const response = await fetch(`/api/switchbot/devices/${deviceId}/commands`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            command: command,
            parameter: 'default'
          })
        });
        
        const data = await response.json();

        if (data.statusCode === 100) {
          showInfo(`Successfully sent ${safeCommand} command to ${safeDeviceName}.`);
          // Refresh device data after command
          setTimeout(() => refreshDeviceData(deviceId), 2000);
        } else {
          throw new Error(data.message || 'Command failed');
        }
      } catch (error) {
        console.error('Failed to control device:', error);
        showError(`Failed to control device: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }
  </script>
</body>
</html>