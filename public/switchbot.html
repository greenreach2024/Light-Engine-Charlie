<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SwitchBot Device Manager - Light Engine Charlie</title>
  <link rel="stylesheet" href="./styles.charlie.css?v=charlie-0.5">
  <style>
    .switchbot-header {
      background: linear-gradient(135deg, #3B82F6, #1E40AF);
      color: white;
      padding: 20px;
      margin: -16px -16px 20px -16px;
      border-radius: 8px 8px 0 0;
    }
    .device-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 16px;
      margin: 16px 0;
    }
    .device-card {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.2s ease;
      margin-bottom: 16px;
      overflow: hidden;
      min-height: 200px;
    }
    .device-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }
    .device-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
      min-height: 50px;
    }
    .device-info {
      clear: both;
      margin-top: 8px;
    }
    .device-controls {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .control-button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 12px;
      transition: all 0.2s ease;
      min-width: 60px;
    }
    .control-button.on {
      background: #10b981;
      color: white;
    }
    .control-button.off {
      background: #ef4444;
      color: white;
    }
    .control-button:hover {
      transform: scale(1.05);
    }
    .control-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .device-status {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .status-online { background: #10b981; }
    .status-offline { background: #ef4444; }
    .reading-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 8px;
      margin: 12px 0;
    }
    .reading-item {
      text-align: center;
      padding: 8px;
      background: #f8fafc;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }
    .reading-value {
      font-size: 18px;
      font-weight: 600;
      color: #1e40af;
    }
    .reading-label {
      font-size: 11px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .sync-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: #f1f5f9;
      border-radius: 6px;
      margin-bottom: 16px;
    }
    .sync-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #10b981;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .error-message {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
      padding: 12px;
      border-radius: 6px;
      margin: 16px 0;
    }
    .info-message {
      background: #eff6ff;
      border: 1px solid #dbeafe;
      color: #1e40af;
      padding: 12px;
      border-radius: 6px;
      margin: 16px 0;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #64748b;
    }
      
      /* Real device styling */
      .device-type-badge.real-device {
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
        box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
      }
      
      .live-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: linear-gradient(135deg, #e8f5e8, #f0fff0);
        border: 1px solid #28a745;
        border-radius: 6px;
        margin-bottom: 8px;
      }
      
      .pulse-dot {
        width: 8px;
        height: 8px;
        background: #28a745;
        border-radius: 50%;
        animation: pulse 2s infinite;
      }
      
      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }
      
      .device-status.online {
        color: #28a745;
        font-weight: 600;
      }

      .device-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 12px 0;
      }

      .device-summary-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        background: linear-gradient(135deg, #f8fafc, #eef2ff);
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
        min-width: 120px;
      }

      .device-summary-icon {
        font-size: 18px;
      }

      .device-summary-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .device-summary-value {
        font-weight: 600;
        color: #1e293b;
        font-size: 13px;
      }

      .device-summary-label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.4px;
        color: #64748b;
      }
  </style>
</head>
<body>
  <div style="padding: 16px; max-width: 1200px; margin: 0 auto;">
    <div class="switchbot-header">
      <h1 style="margin: 0; font-size: 24px;">üè† SwitchBot Device Manager</h1>
      <p style="margin: 8px 0 0; opacity: 0.9;">Live monitoring and control of SwitchBot devices with comprehensive data</p>
      <details style="margin-top: 8px;">
        <summary style="cursor: pointer; font-size: 12px; color: #64748b;">üìä Available Data Fields</summary>
        <div style="margin-top: 8px; padding: 8px; background: #f8fafc; border-radius: 6px; font-size: 11px; color: #64748b;">
          <strong>Environmental:</strong> Temperature, Humidity, CO‚ÇÇ, Light Level, Motion Detection<br>
          <strong>Power:</strong> On/Off Status, Voltage, Current, Daily Usage, Power Consumption<br>
          <strong>Device:</strong> Battery Level, Signal Strength, Firmware Version, Connection Type<br>
          <strong>Management:</strong> Zone Assignment, Farm Location, Equipment Control
        </div>
      </details>
    </div>

    <div class="sync-status" id="syncStatus">
      <div class="sync-indicator" id="syncIndicator"></div>
      <span id="syncText">Loading environment data...</span>
      <button id="btnRefresh" type="button" class="ghost" style="margin-left: auto;">Refresh</button>
    </div>

    <div class="row" style="justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <div>
        <h2 style="margin: 0;">SwitchBot Devices</h2>
        <p class="tiny" style="margin: 4px 0 0; color: #64748b;" id="deviceCount">Loading...</p>
      </div>
      <div class="row" style="gap: 8px;">
        <button id="btnStartPolling" type="button" class="primary">Start Polling</button>
        <button id="btnOpenMain" type="button" class="ghost">‚Üê Back to Dashboard</button>
      </div>
    </div>

    <div id="errorContainer"></div>
    <div id="infoContainer"></div>
    <div id="loadingContainer" class="loading" style="display: none;">
      <div>üîÑ Loading devices...</div>
    </div>
    
    <div id="devicesContainer" class="device-grid">
      <!-- Devices will be loaded here -->
    </div>
  </div>

  <script>
    let devices = [];
    let syncInterval = null;
    let environmentData = [];
    const deviceMetadataMap = new Map();
    let deviceMetadataLoaded = false;
    let deviceMetadataPromise = null;
    let baseZoneOptions = [];
    let baseRoomOptions = [];
    let availableZones = [];
    let availableRooms = [];
    const fallbackCounters = { zone: 0, room: 0 };

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function escapeAttribute(value) {
      return escapeHtml(value);
    }

    function slugify(value) {
      return String(value ?? '')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    }

    function nextFallbackValue(prefix) {
      fallbackCounters[prefix] = (fallbackCounters[prefix] || 0) + 1;
      return `${prefix}-${fallbackCounters[prefix]}`;
    }

    function createOption(id, name, prefix) {
      const trimmedName = typeof name === 'string' ? name.trim() : '';
      const trimmedId = typeof id === 'string' ? id.trim() : '';
      const displayName = trimmedName || trimmedId;
      if (!displayName) return null;
      let value = trimmedId;
      if (!value) {
        const slug = slugify(displayName);
        value = slug ? `${prefix}-${slug}` : nextFallbackValue(prefix);
      }
      return {
        id: trimmedId || null,
        name: displayName,
        value
      };
    }

    function normalizeZoneOption(zone, index = 0) {
      if (!zone) return null;
      if (typeof zone === 'string') {
        return createOption(null, zone, 'zone');
      }
      if (typeof zone === 'object') {
        const source = zone;
        const id = source.id || source.zoneId || source.zone_id || source.zone || source.identifier || null;
        const name = source.name || source.displayName || source.label || source.zone || source.location || id || `Zone ${index + 1}`;
        return createOption(id, name, 'zone');
      }
      return null;
    }

    function normalizeRoomOption(room, index = 0) {
      if (!room) return null;
      if (typeof room === 'string') {
        return createOption(null, room, 'room');
      }
      if (typeof room === 'object') {
        const source = room;
        const id = source.id || source.roomId || source.room_id || source.identifier || null;
        const name = source.name || source.label || source.title || source.roomName || source.location || id || `Room ${index + 1}`;
        return createOption(id, name, 'room');
      }
      return null;
    }

    function dedupeAndSortOptions(options) {
      const map = new Map();
      (options || []).forEach(option => {
        if (!option || !option.value) return;
        if (!map.has(option.value)) {
          map.set(option.value, option);
        } else {
          const existing = map.get(option.value);
          if (!existing.name && option.name) {
            map.set(option.value, option);
          }
        }
      });
      return Array.from(map.values()).sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
      );
    }

    function findOption(list, value) {
      if (!value) return null;
      const normalized = String(value).trim();
      if (!normalized) return null;
      return (list || []).find(
        option =>
          option.value === normalized ||
          option.id === normalized ||
          option.name === normalized
      ) || null;
    }

    function setBaseZoneOptions(options) {
      baseZoneOptions = dedupeAndSortOptions(options || []);
      rebuildZoneOptions();
    }

    function setBaseRoomOptions(options) {
      baseRoomOptions = dedupeAndSortOptions(options || []);
      rebuildRoomOptions();
    }

    function extractZoneOptionsFromMetadata(meta) {
      if (!meta || typeof meta !== 'object') return [];
      const details = meta.details || {};
      const candidates = [
        createOption(details.zoneId || details.zoneSlug || null, details.zoneName || details.zone, 'zone'),
        createOption(meta.zoneId || meta.zoneSlug || null, meta.zoneName || meta.zone, 'zone'),
        createOption(null, meta.zone, 'zone')
      ];
      return candidates.filter(Boolean);
    }

    function extractRoomOptionsFromMetadata(meta) {
      if (!meta || typeof meta !== 'object') return [];
      const details = meta.details || {};
      const assigned = meta.assignedEquipment || {};
      const candidates = [
        createOption(details.roomId || details.roomSlug || null, details.roomName || details.room || details.location, 'room'),
        createOption(meta.roomId || meta.roomSlug || null, meta.roomName || meta.room || meta.location, 'room'),
        createOption(assigned.roomId || null, assigned.roomName || assigned.room || null, 'room')
      ];
      const enriched = candidates
        .filter(Boolean)
        .map(option => {
          if (option && option.id && !option.name) {
            const match = findOption(baseRoomOptions, option.id);
            if (match) {
              return createOption(match.id, match.name, 'room');
            }
          }
          return option;
        });
      return enriched.filter(Boolean);
    }

    function rebuildZoneOptions() {
      const combined = [...baseZoneOptions];
      deviceMetadataMap.forEach(meta => {
        combined.push(...extractZoneOptionsFromMetadata(meta));
      });
      availableZones = dedupeAndSortOptions(combined);
    }

    function rebuildRoomOptions() {
      const combined = [...baseRoomOptions];
      deviceMetadataMap.forEach(meta => {
        combined.push(...extractRoomOptionsFromMetadata(meta));
      });
      availableRooms = dedupeAndSortOptions(combined);
    }

    function findZoneOption(value) {
      return findOption(availableZones, value) || findOption(baseZoneOptions, value);
    }

    function findRoomOption(value) {
      return findOption(availableRooms, value) || findOption(baseRoomOptions, value);
    }

    function getCanonicalDeviceId(source) {
      if (!source || typeof source !== 'object') return '';
      const candidate =
        source.device_id ??
        source.deviceId ??
        source.id ??
        source.uuid ??
        source.deviceID ??
        source.macAddress ??
        '';
      return typeof candidate === 'string'
        ? candidate.trim()
        : String(candidate || '').trim();
    }

    function normalizeMetadata(raw) {
      if (!raw || typeof raw !== 'object') return null;
      return { ...raw };
    }

    function storeDeviceMetadata(raw) {
      const normalized = normalizeMetadata(raw);
      if (!normalized) return null;
      const id = getCanonicalDeviceId(normalized);
      if (!id) return null;
      normalized.device_id = id;
      deviceMetadataMap.set(id.toLowerCase(), normalized);
      return normalized;
    }

    function getDeviceMetadata(deviceId) {
      const key =
        typeof deviceId === 'string'
          ? deviceId.trim()
          : String(deviceId || '').trim();
      if (!key) return null;
      return deviceMetadataMap.get(key.toLowerCase()) || null;
    }

    function getZoneSelection(metadata, device) {
      const candidates = [];
      if (metadata && typeof metadata === 'object') {
        const details = metadata.details || {};
        candidates.push({ value: details.zoneSlug, label: details.zoneName || details.zone });
        candidates.push({ value: details.zoneId, label: details.zoneName || details.zone });
        candidates.push({ value: metadata.zoneSlug, label: metadata.zoneName });
        candidates.push({ value: metadata.zoneId, label: metadata.zoneName });
        candidates.push({ value: metadata.zone, label: metadata.zone });
      }
      if (device && typeof device === 'object') {
        candidates.push({ value: device.zoneId, label: device.zoneName });
        candidates.push({ value: device.zone, label: device.zoneName || device.zone });
      }
      for (const candidate of candidates) {
        if (!candidate) continue;
        const { value, label } = candidate;
        if (value) {
          const option = findZoneOption(value) || findZoneOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
          return {
            value: String(value).trim(),
            label: label ? String(label).trim() : String(value).trim()
          };
        }
        if (label) {
          const option = findZoneOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
        }
      }
      return { value: '', label: '' };
    }

    function getRoomSelection(metadata, device) {
      const candidates = [];
      if (metadata && typeof metadata === 'object') {
        const details = metadata.details || {};
        const assigned = metadata.assignedEquipment || {};
        candidates.push({ value: details.roomSlug, label: details.roomName || details.room || details.location });
        candidates.push({ value: details.roomId, label: details.roomName || details.room || details.location });
        candidates.push({ value: metadata.roomSlug, label: metadata.roomName || metadata.room || metadata.location });
        candidates.push({ value: metadata.roomId, label: metadata.roomName || metadata.room || metadata.location });
        candidates.push({ value: assigned.roomId, label: assigned.roomName || assigned.room });
        candidates.push({ value: metadata.location, label: metadata.location });
      }
      if (device && typeof device === 'object') {
        candidates.push({ value: device.farmLocationId, label: device.farmLocation });
        candidates.push({ value: device.farmLocation, label: device.farmLocation });
      }
      for (const candidate of candidates) {
        if (!candidate) continue;
        const { value, label } = candidate;
        if (value) {
          const option = findRoomOption(value) || findRoomOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
          return {
            value: String(value).trim(),
            label: label ? String(label).trim() : String(value).trim()
          };
        }
        if (label) {
          const option = findRoomOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
        }
      }
      return { value: '', label: '' };
    }

    function computeVPD(tempC, humidityPercent) {
      const temp = Number(tempC);
      const rh = Number(humidityPercent);
      if (!Number.isFinite(temp) || !Number.isFinite(rh)) return null;
      const clampedRh = Math.min(Math.max(rh, 0), 100);
      const saturationVaporPressure = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));
      const deficit = saturationVaporPressure * (1 - clampedRh / 100);
      const rounded = Math.round(deficit * 100) / 100;
      return Number.isFinite(rounded) ? rounded : null;
    }

    function formatNumber(value, decimals = 1) {
      const num = Number(value);
      if (!Number.isFinite(num)) return String(value);
      const fixed = num.toFixed(decimals);
      return fixed.replace(/\.0+$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
    }

    function getPowerState(reading = {}) {
      if (!reading || typeof reading !== 'object') return null;
      const candidates = [
        reading.power,
        reading.powerState,
        reading.powerStatus,
        reading.switch,
        reading.switchStatus,
        reading.status,
        reading.state
      ];
      for (const candidate of candidates) {
        if (candidate === undefined || candidate === null) continue;
        if (typeof candidate === 'string') {
          const normalized = candidate.trim().toLowerCase();
          if (normalized === 'on' || normalized === 'open' || normalized === 'true') return 'on';
          if (normalized === 'off' || normalized === 'closed' || normalized === 'false') return 'off';
        } else if (typeof candidate === 'boolean') {
          return candidate ? 'on' : 'off';
        } else if (typeof candidate === 'number') {
          if (candidate === 1) return 'on';
          if (candidate === 0) return 'off';
          return candidate > 0 ? 'on' : 'off';
        }
      }
      return null;
    }

    function getBatteryIcon(level) {
      const numeric = Number(level);
      if (!Number.isFinite(numeric)) return 'üîã';
      if (numeric >= 70) return 'üîã';
      if (numeric >= 30) return 'ü™´';
      return 'üî¥';
    }

    function isPlugDevice(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      return type.includes('plug') || type.includes('outlet') || type.includes('switch');
    }

    function isSensorDevice(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      return (
        type.includes('sensor') ||
        type.includes('meter') ||
        type.includes('monitor') ||
        type.includes('woiosensor')
      );
    }

    function enrichReading(reading) {
      if (!reading || typeof reading !== 'object') return reading;
      const enriched = { ...reading };
      if (
        enriched.vpd === undefined &&
        typeof enriched.temperature === 'number' &&
        typeof enriched.humidity === 'number'
      ) {
        const computed = computeVPD(enriched.temperature, enriched.humidity);
        if (computed !== null) {
          enriched.vpd = computed;
        }
      }
      if (enriched.weight !== undefined && enriched.wattage === undefined) {
        enriched.wattage = enriched.weight;
      }
      return enriched;
    }

    function enrichDeviceReading(device) {
      if (device && device.lastReading) {
        device.lastReading = enrichReading(device.lastReading);
      }
    }

    function applyMetadataToDevice(device, metadataOverride) {
      if (!device) return;
      const metadata = metadataOverride || getDeviceMetadata(getCanonicalDeviceId(device));
      enrichDeviceReading(device);
      if (metadata) {
        const nameFromMeta =
          metadata.name ||
          metadata.deviceName ||
          (metadata.details && (metadata.details.displayName || metadata.details.name));
        if (nameFromMeta) {
          device.displayName = nameFromMeta;
        }
        const zoneSelection = getZoneSelection(metadata, device);
        device.zoneId = zoneSelection.value || '';
        device.zoneName = zoneSelection.label || '';
        const roomSelection = getRoomSelection(metadata, device);
        device.farmLocationId = roomSelection.value || '';
        device.farmLocation = roomSelection.label || '';
        const metadataDetails = metadata.details || {};
        const managed =
          metadataDetails.managedEquipment ??
          metadata.managedEquipment ??
          device.managedEquipment ??
          '';
        device.managedEquipment = managed || '';
      } else {
        if (!device.displayName) {
          device.displayName = device.deviceName || device.device_id || device.deviceId;
        }
        enrichDeviceReading(device);
      }
    }

    function applyMetadataToAllDevices() {
      devices.forEach(device => {
        applyMetadataToDevice(device);
      });
    }

    function renderSelectOptions(options, selectedValue, selectedLabel, placeholder) {
      const normalizedSelected = selectedValue ? String(selectedValue).trim() : '';
      const html = [
        `<option value=""${normalizedSelected ? '' : ' selected'}>${escapeHtml(placeholder)}</option>`
      ];
      let hasSelected = false;
      (options || []).forEach(option => {
        if (!option || !option.value) return;
        const isSelected = normalizedSelected && option.value === normalizedSelected;
        if (isSelected) hasSelected = true;
        html.push(
          `<option value="${escapeAttribute(option.value)}"${isSelected ? ' selected' : ''}>${escapeHtml(option.name)}</option>`
        );
      });
      if (normalizedSelected && !hasSelected) {
        html.push(
          `<option value="${escapeAttribute(normalizedSelected)}" selected>${escapeHtml(selectedLabel || normalizedSelected)}</option>`
        );
      }
      return html.join('');
    }

    function createDeviceSummary(device, reading) {
      if (!device || !reading || typeof reading !== 'object') return '';
      const type = String(device.deviceType || '').toLowerCase();
      const items = [];
      if (isPlugDevice(type)) {
        const state = getPowerState(reading);
        if (state) {
          items.push({
            icon: state === 'on' ? 'üü¢' : 'üî¥',
            label: 'Status',
            value: state.toUpperCase()
          });
        }
        if (reading.wattage !== undefined) {
          items.push({ icon: '‚ö°', label: 'Wattage', value: `${formatNumber(reading.wattage, 1)} W` });
        }
        if (reading.voltage !== undefined) {
          items.push({ icon: 'üîå', label: 'Voltage', value: `${formatNumber(reading.voltage, 1)} V` });
        }
        if (reading.electricCurrent !== undefined) {
          items.push({ icon: 'üîã', label: 'Current', value: `${formatNumber(reading.electricCurrent, 2)} A` });
        }
      } else if (isSensorDevice(type)) {
        if (reading.temperature !== undefined) {
          items.push({ icon: 'üå°Ô∏è', label: 'Temperature', value: `${formatNumber(reading.temperature, 1)} ¬∞C` });
        }
        if (reading.humidity !== undefined) {
          items.push({ icon: 'üíß', label: 'Humidity', value: `${formatNumber(reading.humidity, 1)} %` });
        }
        const vpdValue = reading.vpd ?? computeVPD(reading.temperature, reading.humidity);
        if (vpdValue !== null && vpdValue !== undefined) {
          items.push({ icon: 'üåø', label: 'VPD', value: `${formatNumber(vpdValue, 2)} kPa` });
        }
        if (reading.battery !== undefined) {
          items.push({ icon: getBatteryIcon(reading.battery), label: 'Battery', value: `${formatNumber(reading.battery, 0)}%` });
        }
      }
      if (!items.length) return '';
      const chips = items
        .map(item => `
          <div class="device-summary-item">
            <span class="device-summary-icon">${item.icon}</span>
            <div class="device-summary-text">
              <div class="device-summary-value">${escapeHtml(item.value)}</div>
              <div class="device-summary-label">${escapeHtml(item.label)}</div>
            </div>
          </div>
        `)
        .join('');
      return `<div class="device-summary">${chips}</div>`;
    }

    async function fetchEnvironmentData() {
      try {
        // Try multiple data sources for SwitchBot data
        const dataSources = [
          '/env',  // Local environment endpoint
          '/api/azure/telemetry',  // Azure telemetry API
          '/api/azure/iot-hub'     // Azure IoT Hub data
        ];
        
        for (const source of dataSources) {
          try {
            const response = await fetch(source);
            if (response.ok) {
              const data = await response.json();
              console.log(`Successfully fetched data from ${source}`);
              return data.zones || data.devices || data || [];
            }
          } catch (error) {
            console.warn(`Failed to fetch from ${source}:`, error.message);
          }
        }
        
        throw new Error('No data sources available');
      } catch (error) {
        console.error('Environment API Error:', error);
        throw error;
      }
    }

    async function ensureEnvironmentData(force = false) {
      const hadData = Array.isArray(environmentData) && environmentData.length > 0;
      if (!force && hadData) {
        return environmentData;
      }

      try {
        const data = await fetchEnvironmentData();
        const normalized = Array.isArray(data) ? data : [];
        environmentData = normalized;
        const zoneOptions = normalized
          .map((zone, index) => normalizeZoneOption(zone, index))
          .filter(Boolean);
        setBaseZoneOptions(zoneOptions);
        return environmentData;
      } catch (error) {
        if (!hadData) {
          environmentData = [];
          setBaseZoneOptions([]);
        }
        throw error;
      }
    }

    async function fetchFarmRooms() {
      const collected = [];

      try {
        const response = await fetch('/farm');
        if (response.ok) {
          const data = await response.json();
          const rawRooms = Array.isArray(data?.rooms)
            ? data.rooms
            : Array.isArray(data?.farm?.rooms)
            ? data.farm.rooms
            : [];
          rawRooms.forEach((room, index) => {
            const option = normalizeRoomOption(room, index);
            if (option) collected.push(option);
          });
        }
      } catch (error) {
        console.warn('Failed to load rooms from /farm:', error);
      }

      if (collected.length === 0) {
        try {
          const response = await fetch('/data/rooms.json');
          if (response.ok) {
            const data = await response.json();
            const rawRooms = Array.isArray(data?.rooms) ? data.rooms : [];
            rawRooms.forEach((room, index) => {
              const option = normalizeRoomOption(room, index);
              if (option) collected.push(option);
            });
          }
        } catch (error) {
          console.warn('Failed to load fallback room list:', error);
        }
      }

      setBaseRoomOptions(collected);
      return collected;
    }

    async function fetchDeviceMetadata() {
      try {
        const response = await fetch('/devices');
        if (!response.ok) {
          throw new Error(`Failed to load device metadata (${response.status})`);
        }
        const payload = await response.json();
        const list = Array.isArray(payload?.devices)
          ? payload.devices
          : Array.isArray(payload)
          ? payload
          : [];

        deviceMetadataMap.clear();
        list.forEach(item => {
          storeDeviceMetadata(item);
        });
        rebuildZoneOptions();
        rebuildRoomOptions();
        deviceMetadataLoaded = true;
        return list;
      } catch (error) {
        console.warn('Failed to load device metadata:', error);
        deviceMetadataLoaded = false;
        return [];
      }
    }

    async function loadDeviceMetadataIfNeeded(force = false) {
      if (!force && deviceMetadataLoaded && deviceMetadataMap.size > 0) {
        return;
      }
      if (deviceMetadataPromise) {
        await deviceMetadataPromise;
        return;
      }
      deviceMetadataPromise = fetchDeviceMetadata().finally(() => {
        deviceMetadataPromise = null;
      });
      await deviceMetadataPromise;
    }

    async function loadReferenceData() {
      await Promise.all([
        ensureEnvironmentData().catch(error => {
          console.warn('Environment data unavailable:', error);
          return [];
        }),
        fetchFarmRooms().catch(error => {
          console.warn('Room catalogue unavailable:', error);
          return [];
        }),
        (async () => {
          try {
            await loadDeviceMetadataIfNeeded();
          } catch (error) {
            console.warn('Device metadata unavailable:', error);
          }
        })()
      ]);

      applyMetadataToAllDevices();
    }

    function sanitizeMetadataPayload(updates = {}) {
      const result = {};
      Object.entries(updates).forEach(([key, value]) => {
        if (value === undefined) {
          return;
        }
        if (value === '') {
          result[key] = null;
          return;
        }
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          result[key] = { ...value };
        } else {
          result[key] = value;
        }
      });
      return result;
    }

    async function fetchJson(url, options = {}) {
      const response = await fetch(url, options);
      const text = await response.text();
      let data = null;
      if (text) {
        try {
          data = JSON.parse(text);
        } catch (error) {
          data = null;
        }
      }
      return { response, data };
    }

    async function persistDeviceMetadata(device, updates = {}) {
      const deviceId = getCanonicalDeviceId(device);
      if (!deviceId) {
        throw new Error('Unable to determine device id for metadata update');
      }

      const payload = sanitizeMetadataPayload(updates);
      let result = await fetchJson(`/devices/${encodeURIComponent(deviceId)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (result.response.status === 404) {
        const createPayload = sanitizeMetadataPayload({
          id: deviceId,
          protocol: 'switchbot',
          category: device?.deviceType || 'SwitchBot Device',
          name: device?.displayName || device?.deviceName || deviceId,
          deviceName: device?.displayName || device?.deviceName || deviceId,
          manufacturer: 'SwitchBot',
          model: device?.deviceType || device?.deviceName || 'SwitchBot',
          ...updates
        });
        result = await fetchJson('/devices', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(createPayload)
        });
      }

      const { response, data } = result;
      if (!response.ok) {
        const message = (data && (data.error || data.message)) || `Request failed with status ${response.status}`;
        const error = new Error(message);
        error.status = response.status;
        error.data = data;
        throw error;
      }

      const saved = data && (data.device || data);
      if (saved) {
        const normalized = storeDeviceMetadata(saved);
        rebuildZoneOptions();
        rebuildRoomOptions();
        return normalized || saved;
      }

      return saved;
    }

    async function fetchSwitchBotDevices() {
      try {
        // Fetch real SwitchBot devices from your farm
        const response = await fetch('/api/switchbot/devices');
        if (response.status === 429) {
          throw new Error('SwitchBot API rate limit reached. Please wait before making more requests.');
        }
        
        const data = await response.json();
        
        if (data.statusCode !== 100) {
          throw new Error(`SwitchBot API Error: ${data.message || 'Unknown error'}`);
        }
        
        return data.body?.deviceList || [];
      } catch (error) {
        console.error('SwitchBot API Error:', error);
        throw error;
      }
    }

    async function getDevices() {
      // Try to get live devices from SwitchBot API (with rate limiting protection)
      try {
        return await fetchSwitchBotDevices();
      } catch (error) {
        console.warn('SwitchBot API failed, using environment data:', error.message);
        // Fallback to environment data which includes SwitchBot readings
        const envData = await fetchEnvironmentData();
        return envData.filter(zone => zone.source === 'switchbot').map(zone => ({
          deviceId: zone.name || zone.zoneId,
          deviceName: zone.name || zone.zoneId,
          deviceType: 'SwitchBot Sensor',
          lastReading: zone
        }));
      }
    }

    async function getDeviceStatus(deviceId) {
      // For devices from environment data, return cached readings
      const envDevice = environmentData.find(zone => 
        (zone.name === deviceId || zone.zoneId === deviceId) && zone.source === 'switchbot'
      );
      
      if (envDevice) {
        return {
          statusCode: 100,
          body: {
            temperature: envDevice.temperature,
            humidity: envDevice.humidity,
            co2: envDevice.co2,
            battery: envDevice.battery,
            timestamp: envDevice.timestamp
          }
        };
      }
      
      // Try SwitchBot API as fallback (with rate limiting protection)
      try {
        const response = await fetch(`/api/switchbot/devices/${deviceId}/status`);
        if (response.status === 429) {
          throw new Error('Rate limit reached');
        }
        return await response.json();
      } catch (error) {
        console.warn(`Status fetch failed for ${deviceId}:`, error.message);
        return null;
      }
    }

    async function sendCommand(deviceId, command, parameter = '', commandType = 'command') {
      const response = await fetch(`/api/switchbot/devices/${deviceId}/commands`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          command,
          parameter,
          commandType
        })
      });

      const data = await response.json();
      if (!response.ok || data.statusCode !== 100) {
        const message = data?.message || `Command failed with status ${response.status}`;
        const error = new Error(message);
        error.data = data;
        error.status = response.status;
        throw error;
      }
      return data;
    }

    function showError(message) {
      const container = document.getElementById('errorContainer');
      container.innerHTML = `
        <div class="error-message">
          <strong>Error:</strong> ${message}
        </div>
      `;
    }

    function clearError() {
      document.getElementById('errorContainer').innerHTML = '';
    }

    function updateSyncStatus(status, isError = false) {
      const syncText = document.getElementById('syncText');
      const syncIndicator = document.getElementById('syncIndicator');
      
      syncText.textContent = status;
      
      if (isError) {
        syncIndicator.style.background = '#ef4444';
        syncIndicator.style.animation = 'none';
      } else {
        syncIndicator.style.background = '#10b981';
        syncIndicator.style.animation = 'pulse 2s infinite';
      }
    }

    function formatReading(value, unit = '') {
      if (value === null || value === undefined) return '--';
      if (typeof value === 'boolean') return value ? 'Yes' : 'No';
      return `${value}${unit}`;
    }

    function createDeviceCard(device, status = null) {
      const isOnline = status && status.body;
      const readings = status?.body || {};
      
      const batteryLevel = readings.battery !== undefined ? readings.battery : null;
      const batteryIcon = batteryLevel !== null ? 
        (batteryLevel > 70 ? 'üîã' : batteryLevel > 30 ? 'ü™´' : 'üî¥') : 'üîå';

      // Enhanced device metadata
      const deviceModel = device.deviceType || 'Unknown';
      const firmwareVersion = readings.version?.BLE || device.version || '--';
      const lastUpdate = readings.lastUpdate || new Date().toISOString();
      const connectivity = readings.hubDeviceId ? 'üåê Hub Connected' : 'üì∂ Direct';

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${deviceModel}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
              ${device.hubDeviceId ? `<p class="tiny" style="margin: 2px 0 0; color: #64748b;">Hub: ${device.hubDeviceId}</p>` : ''}
              ${firmwareVersion !== '--' ? `<p class="tiny" style="margin: 2px 0 0; color: #64748b;">FW: ${firmwareVersion}</p>` : ''}
            </div>
            <div style="text-align: right;">
              ${batteryLevel !== null ? 
                `<div title="Battery: ${batteryLevel}%">${batteryIcon} ${batteryLevel}%</div>` : 
                '<div title="Powered">üîå AC</div>'
              }
              <div class="tiny" style="color: #64748b; margin-top: 2px;">${connectivity}</div>
              <button class="ghost tiny" onclick="refreshDevice('${device.deviceId}')" style="margin-top: 4px;">üîÑ</button>
            </div>
          </div>
          
          ${createReadingsGrid(readings, device.deviceType)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last sync: ${new Date(lastUpdate).toLocaleTimeString()}
            </span>
            ${createDeviceControls(device)}
          </div>
        </div>
      `;
    }

    function createReadingsGrid(readings, deviceType) {
      const readingItems = [];
      
      // Temperature
      if (readings.temperature !== undefined) {
        const tempIcon = readings.temperature > 25 ? 'üå°Ô∏è' : readings.temperature < 18 ? '‚ùÑÔ∏è' : 'üå°Ô∏è';
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${tempIcon} ${formatReading(readings.temperature, '¬∞C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (readings.humidity !== undefined) {
        const humidityIcon = readings.humidity > 70 ? 'üíß' : readings.humidity < 30 ? 'üèúÔ∏è' : 'üí®';
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${humidityIcon} ${formatReading(readings.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // Power state for plugs
      if (readings.power !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${readings.power === 'on' ? 'üü¢ ON' : 'üî¥ OFF'}</div>
            <div class="reading-label">Power</div>
          </div>
        `);
      }
      
      // Voltage (for plugs)
      if (readings.voltage !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">‚ö° ${formatReading(readings.voltage, 'V')}</div>
            <div class="reading-label">Voltage</div>
          </div>
        `);
      }
      
      // Current (for plugs)
      if (readings.electricCurrent !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">üîå ${formatReading(readings.electricCurrent, 'A')}</div>
            <div class="reading-label">Current</div>
          </div>
        `);
      }
      
      // Power consumption (for plugs)
      if (readings.electricityOfDay !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">üí° ${formatReading(readings.electricityOfDay, 'kWh')}</div>
            <div class="reading-label">Daily Usage</div>
          </div>
        `);
      }
      
      // Instant power consumption (for plugs)
      if (readings.weight !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">‚ö° ${formatReading(readings.weight, 'W')}</div>
            <div class="reading-label">Power</div>
          </div>
        `);
      }
      
      // Motion detection
      if (readings.moveDetected !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${readings.moveDetected ? 'üèÉ Detected' : 'üö∂ None'}</div>
            <div class="reading-label">Motion</div>
          </div>
        `);
      }
      
      // Light level/Brightness
      if (readings.brightness !== undefined) {
        const lightIcon = readings.brightness > 50 ? '‚òÄÔ∏è' : readings.brightness > 20 ? 'üå§Ô∏è' : 'üåô';
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${lightIcon} ${formatReading(readings.brightness, '%')}</div>
            <div class="reading-label">Light Level</div>
          </div>
        `);
      }
      
      // Illuminance (lux)
      if (readings.lightLevel !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">üí° ${formatReading(readings.lightLevel, 'lux')}</div>
            <div class="reading-label">Illuminance</div>
          </div>
        `);
      }
      
      // Contact sensor
      if (readings.openState !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${readings.openState === 'open' ? 'üö™ Open' : 'üö™ Closed'}</div>
            <div class="reading-label">Door/Window</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (readings.version !== undefined && typeof readings.version === 'object' && readings.version.rssi) {
        const rssiValue = readings.version.rssi;
        const signalIcon = rssiValue > -50 ? 'üì∂' : rssiValue > -70 ? 'üì∂' : 'üì∂';
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${signalIcon} ${formatReading(rssiValue, 'dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      // Device version/firmware
      if (readings.version !== undefined && typeof readings.version === 'object' && readings.version.BLE) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">üì± ${readings.version.BLE}</div>
            <div class="reading-label">Firmware</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`ÔøΩ Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh (üîÑ) to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`‚úÖ Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          }));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('‚ö†Ô∏è No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('‚ùå Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      
      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${reading?.battery ? `<div title="Battery: ${reading.battery}%">üîã ${reading.battery}%</div>` : '<div title="Powered">üîå</div>'}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 4px;">üîÑ</button>
            </div>
          </div>
          
          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '¬∞C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO‚ÇÇ</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function renderDevicesFromAPI() {
      const container = document.getElementById('devicesContainer');

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found</p>';
        return;
      }

      applyMetadataToAllDevices();

      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.lastUpdate &&
          (Date.now() - new Date(reading.lastUpdate).getTime()) < 5 * 60 * 1000; // 5 minutes

        return createAPIDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createAPIDeviceCard(device, reading, isOnline) {
      const metadata = getDeviceMetadata(getCanonicalDeviceId(device));
      enrichDeviceReading(device);
      const currentReading = device.lastReading || reading || {};
      const statusColor = isOnline ? '#10b981' : '#ef4444';
      const statusText = isOnline ? 'ONLINE' : 'OFFLINE';
      const lastUpdate = currentReading?.lastUpdate ? new Date(currentReading.lastUpdate).toLocaleString() : 'Never';
      const deviceIcon = getDeviceIcon(device.deviceType);
      const deviceCategory = getDeviceCategory(device.deviceType);
      const displayName = escapeHtml(device.displayName || device.deviceName || device.deviceId);
      const safeDeviceType = escapeHtml(device.deviceType || 'SwitchBot Device');
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);
      const safeDeviceIdLabel = escapeHtml(device.deviceId);
      const zoneSelection = getZoneSelection(metadata, device);
      const roomSelection = getRoomSelection(metadata, device);
      const zoneOptionsHtml = renderSelectOptions(availableZones, zoneSelection.value, zoneSelection.label, 'Select Zone');
      const roomOptionsHtml = renderSelectOptions(availableRooms, roomSelection.value, roomSelection.label, 'Select Location');
      const isPlug = isPlugDevice(device.deviceType);
      const powerState = getPowerState(currentReading);
      const summaryHtml = createDeviceSummary(device, currentReading);
      const batteryLevel = currentReading?.battery;
      const batteryDisplay = batteryLevel !== undefined && batteryLevel !== null ? `${formatNumber(batteryLevel, 0)}%` : null;
      const batteryMarkup = batteryDisplay !== null
        ? `<div title="Battery: ${escapeHtml(batteryDisplay)}">${getBatteryIcon(batteryLevel)} ${escapeHtml(batteryDisplay)}</div>`
        : '<div title="Powered">üîå AC</div>';
      const connectivityLabel = currentReading?.hubDeviceId ? 'üåê Hub Connected' : 'üì∂ Direct';
      const safeConnectivity = escapeHtml(connectivityLabel);
      const managedEquipmentValue = device.managedEquipment || '';
      const safeManagedEquipmentValue = escapeAttribute(managedEquipmentValue);

      return `
        <div class="device-card" style="border-left: 4px solid ${statusColor}; opacity: ${isOnline ? 1 : 0.7};">
          <div class="device-header">
            <div style="display: flex; align-items: flex-start; gap: 12px; flex: 1; min-width: 0;">
              <div style="font-size: 28px; flex-shrink: 0;">${deviceIcon}</div>
              <div style="flex: 1; min-width: 0; overflow: hidden;">
                <h4 style="margin: 0 0 8px 0; color: #1e293b; font-size: 16px; font-weight: 600; cursor: pointer; line-height: 1.2; word-break: break-word;"
                    onclick="editDeviceName('${safeDeviceIdAttr}')"
                    title="Click to edit device name">
                  ${displayName}
                </h4>
                <div style="display: flex; flex-direction: column; gap: 4px;">
                  <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                    <span style="color: ${statusColor}; font-weight: 600; font-size: 12px; white-space: nowrap;">
                      ${statusText}
                    </span>
                    ${isPlug && powerState ? `<span style="color: ${powerState === 'on' ? '#10b981' : '#64748b'}; font-weight: 600; font-size: 11px; white-space: nowrap;">${powerState.toUpperCase()}</span>` : ''}
                  </div>
                  <div style="color: #64748b; font-size: 11px; line-height: 1.3; word-break: break-word;">
                    ${escapeHtml(deviceCategory)}
                  </div>
                </div>
              </div>
            </div>
            <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px; min-width: 100px;">
              ${batteryMarkup}
              <div class="tiny" style="color: #64748b;">${safeConnectivity}</div>
              <button onclick="refreshDeviceData('${safeDeviceIdAttr}')"
                      class="btn-small"
                      style="background: #0ea5e9; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                üîÑ
              </button>
            </div>
          </div>

          ${summaryHtml ? summaryHtml : ''}

          <div class="device-controls" style="margin: 12px 0;">
            ${createDeviceControls(device)}
          </div>

          <div class="device-info">
            <div style="margin-bottom: 12px;">
              <div style="display: flex; gap: 12px; margin-bottom: 8px;">
                <div style="flex: 1; min-width: 0;">
                  <label class="tiny" style="color: #64748b; display: block; margin-bottom: 4px;">Zone Assignment:</label>
                  <select onchange="updateDeviceZone('${safeDeviceIdAttr}', this.value)"
                          style="width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    ${zoneOptionsHtml}
                  </select>
                </div>
                <div style="flex: 1; min-width: 0;">
                  <label class="tiny" style="color: #64748b; display: block; margin-bottom: 4px;">Farm Location:</label>
                  <select onchange="updateDeviceLocation('${safeDeviceIdAttr}', this.value)"
                          style="width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    ${roomOptionsHtml}
                  </select>
                </div>
              </div>
              ${!isPlug ? '' : `
              <div style="margin-bottom: 8px;">
                <label class="tiny" style="color: #64748b; display: block; margin-bottom: 4px;">Managed Equipment:</label>
                <input type="text"
                       value="${safeManagedEquipmentValue}"
                       onchange="updateManagedEquipment('${safeDeviceIdAttr}', this.value)"
                       placeholder="e.g., Heater, Fan, Lights"
                       style="width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
              </div>
              `}
            </div>

            <div class="device-meta" style="background: #f8fafc; border-radius: 6px; padding: 10px; margin-bottom: 12px;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                <div><strong>Device ID:</strong><br><span style="word-break: break-all; font-size: 10px;">${safeDeviceIdLabel}</span></div>
                <div><strong>Type:</strong><br><span style="font-size: 10px;">${safeDeviceType}</span></div>
                <div><strong>MAC:</strong><br><span style="font-size: 10px;">${escapeHtml(device.macAddress || 'N/A')}</span></div>
                <div><strong>Cloud:</strong><br><span style="font-size: 10px;">${escapeHtml(device.cloudService || 'SwitchBot')}</span></div>
              </div>
            </div>

            ${createAPIReadingsGrid(currentReading)}
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px; flex-wrap: wrap; gap: 8px; border-top: 1px solid #e2e8f0; padding-top: 8px;">
            <span class="tiny" style="color: #64748b; font-size: 10px;">
              Last updated: ${escapeHtml(lastUpdate)}
            </span>
            <span class="tiny" style="color: ${device.isRealDevice ? '#28a745' : '#0ea5e9'}; font-size: 10px;">
              ${device.isRealDevice ? 'üå± Real Farm Device' : 'üéÆ Live Demo API'}
            </span>
          </div>
        </div>
      `;
    }

    function createAPIReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available - click refresh to get data</p>';
      
      // Handle real device messages
      if (reading.message) {
        return `
          <div style="background: linear-gradient(135deg, #e8f5e8, #f0fff0); border: 1px solid #28a745; border-radius: 6px; padding: 12px; margin: 8px 0;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="color: #28a745; font-size: 16px;">üå±</span>
              <span style="color: #28a745; font-weight: 600;">${reading.message}</span>
            </div>
            <p class="tiny" style="margin: 4px 0 0; color: #155724;">
              This is a real device from your farm. Click the refresh button (üîÑ) to get live sensor readings.
            </p>
          </div>
        `;
      }
      
      const readingItems = [];
      
      // Show all available data fields with enhanced formatting
      Object.keys(reading).forEach(key => {
        if (key === 'lastUpdate' || key === 'message' || key === 'deviceId') return;
        
        const value = reading[key];
        if (value === undefined || value === null) return;
        
        let displayValue = value;
        let unit = '';
        let label = key;
        let icon = '';
        
        // Format specific readings with icons and proper units
        switch(key.toLowerCase()) {
          case 'temperature':
            icon = value > 25 ? 'üå°Ô∏è' : value < 18 ? '‚ùÑÔ∏è ' : 'üå°Ô∏è';
            unit = '¬∞C';
            label = 'Temperature';
            break;
          case 'humidity':
            icon = value > 70 ? 'üíß' : value < 30 ? 'üèúÔ∏è' : 'üí®';
            unit = '%';
            label = 'Humidity';
            break;
          case 'vpd':
            icon = 'üåø';
            unit = ' kPa';
            label = 'VPD';
            displayValue = formatNumber(value, 2);
            break;
          case 'co2':
            icon = 'üå¨Ô∏è';
            unit = ' ppm';
            label = 'CO‚ÇÇ';
            break;
          case 'power':
            icon = '‚ö°';
            unit = value === 'on' ? '' : value === 'off' ? '' : 'W';
            label = 'Power';
            if (typeof value === 'string') {
              const normalized = getPowerState({ power: value });
              displayValue = normalized ? normalized.toUpperCase() : value.toUpperCase();
            } else {
              displayValue = value;
            }
            break;
          case 'voltage':
            icon = '‚ö°';
            unit = 'V';
            label = 'Voltage';
            break;
          case 'electriccurrent':
          case 'current':
            icon = 'üîå';
            unit = 'A';
            label = 'Current';
            break;
          case 'electricityofday':
            icon = 'üí°';
            unit = 'kWh';
            label = 'Daily Usage';
            break;
          case 'weight':
            icon = '‚ö°';
            unit = 'W';
            label = 'Wattage';
            break;
          case 'battery':
            icon = getBatteryIcon(value);
            unit = '%';
            label = 'Battery';
            break;
          case 'position':
            icon = 'üìè';
            unit = '%';
            label = 'Position';
            break;
          case 'version':
            icon = 'üì±';
            label = 'Firmware';
            displayValue = typeof value === 'object' ? value.BLE || value.WiFi || JSON.stringify(value) : value;
            break;
          case 'openstate':
            icon = value === 'open' ? 'üö™' : 'üö™';
            label = 'Status';
            displayValue = value === 'open' ? 'OPEN' : 'CLOSED';
            break;
          case 'movedetected':
            icon = value ? 'üèÉ' : 'üö∂';
            label = 'Motion';
            displayValue = value ? 'DETECTED' : 'NONE';
            break;
          case 'brightness':
          case 'lightlevel':
            icon = value > 50 ? '‚òÄÔ∏è' : value > 20 ? 'üå§Ô∏è' : 'üåô';
            label = key.toLowerCase() === 'brightness' ? 'Brightness' : 'Illuminance';
            unit = key.toLowerCase() === 'brightness' ? '%' : 'lux';
            break;
          case 'volume':
            icon = 'üì¢';
            unit = value > 1 ? 'dB' : '';
            label = 'Volume';
            break;
          case 'lightintensity':
            icon = 'üí°';
            unit = 'lux';
            label = 'Light Intensity';
            break;
          case 'scale':
            icon = '‚öñÔ∏è';
            unit = 'kg';
            label = 'Weight';
            break;
          case 'doorstate':
            icon = 'üö™';
            label = 'Door';
            displayValue = value === 1 ? 'OPEN' : 'CLOSED';
            break;
          case 'calibration':
            icon = 'üéØ';
            label = 'Calibration';
            displayValue = value ? 'YES' : 'NO';
            break;
          case 'lackpower':
            icon = value ? '‚ö†Ô∏è' : '‚úÖ';
            label = 'Power Status';
            displayValue = value ? 'LOW POWER' : 'OK';
            break;
          default:
            icon = 'üìä';
            label = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
        }
        
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${icon} ${formatReading(displayValue, unit)}</div>
            <div class="reading-label">${label}</div>
          </div>
        `);
      });
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor data available - click refresh to get readings</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    async function refreshEnvironmentData() {
      try {
        updateSyncStatus('Refreshing environment data...');
        try {
          await ensureEnvironmentData(true);
        } catch (error) {
          console.warn('Environment refresh failed:', error);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotData = sourceData.filter(zone => zone.source === 'switchbot');

        if (switchbotData.length > 0) {
          devices = switchbotData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone
          }));
          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          updateSyncStatus(`‚úÖ Refreshed ${devices.length} devices`);
          document.getElementById('deviceCount').textContent = `${devices.length} devices from environment data`;
        } else {
          updateSyncStatus('‚ö†Ô∏è No SwitchBot data in environment');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
        }
      } catch (error) {
        console.error('Failed to refresh environment data:', error);
        updateSyncStatus('‚ùå Refresh failed', true);
      }
    }

    function startAutoRefresh() {
      if (syncInterval) clearInterval(syncInterval);
      syncInterval = setInterval(refreshEnvironmentData, 30000);
    }

    function stopAutoRefresh() {
      if (syncInterval) {
        clearInterval(syncInterval);
        syncInterval = null;
      }
    }

    function showInfo(message) {
      const container = document.getElementById('infoContainer');
      container.innerHTML = `<div class="info-message"><strong>Info:</strong> ${message}</div>`;
    }

    function clearError() {
      document.getElementById('errorContainer').innerHTML = '';
      document.getElementById('infoContainer').innerHTML = '';
    }

    function startSwitchBotPolling() {
      const button = document.getElementById('btnStartPolling');
      if (button.textContent === 'Start Polling') {
        // Start polling
        showInfo('<strong>üîÑ Starting SwitchBot polling...</strong><br>Collecting device data from local mock API...');
        button.textContent = 'Stop Polling';
        button.style.backgroundColor = '#dc3545';
        
        // Start the polling interval
        window.switchBotPollingInterval = setInterval(async () => {
          try {
            // Instead of loading all devices, just update the device list without fetching all statuses
            const realDevices = await fetchSwitchBotDevices();
            if (realDevices && realDevices.length > 0) {
              devices = realDevices.map(device => ({
                ...device,
                isRealDevice: true,
                lastReading: devices.find(d => d.deviceId === device.deviceId)?.lastReading || {
                  lastUpdate: new Date().toISOString(),
                  message: "Click refresh (üîÑ) to get current readings"
                }
              }));
              renderDevicesFromAPI();
              showInfo(`<strong>‚úÖ Polling active</strong><br>Last update: ${new Date().toLocaleTimeString()}<br>Device list refreshed. Click refresh on cards for live data.`);
            }
          } catch (error) {
            showError(`Polling error: ${error.message}`);
          }
        }, 30000); // Poll every 30 seconds instead of 10
        
        // Immediate first poll
        loadDevices();
        
      } else {
        // Stop polling
        if (window.switchBotPollingInterval) {
          clearInterval(window.switchBotPollingInterval);
          window.switchBotPollingInterval = null;
        }
        button.textContent = 'Start Polling';
        button.style.backgroundColor = '#007bff';
        showInfo('<strong>‚èπÔ∏è Polling stopped</strong><br>Click "Start Polling" to resume data collection.');
      }
    }

    function getSwitchBotToken() {
      return "4e6fc805b4a0dd7ed693af1dcf89d9731113d4706b2d796759aafe09cf8f07aed370d35bab4fb4799e1bda57d03c0aed";
    }

    function getSwitchBotSecret() {
      return "141c0bc9906ab1f4f73dd9f0c298046b";
    }

    async function fetchServerStatus() {
      try {
        const response = await fetch('/status');
        if (response.ok) {
          const status = await response.json();
          const configSpan = document.getElementById('currentConfig');
          if (configSpan) {
            configSpan.innerHTML = `
              <strong>Environment Source:</strong> ${status.envSource || 'local'}<br>
              ${status.azureLatestUrl ? `<strong>Azure URL:</strong> ${status.azureLatestUrl}<br>` : ''}
              <strong>Server:</strong> ${status.controller || 'unknown'}
            `;
          }
        }
      } catch (error) {
        console.error('Failed to fetch server status:', error);
      }
    }

    // Global functions for onclick handlers
    window.refreshEnvironmentData = refreshEnvironmentData;
    window.startSwitchBotPolling = startSwitchBotPolling;

    // Event listeners
    document.addEventListener('DOMContentLoaded', async () => {
      document.getElementById('btnRefresh').addEventListener('click', refreshEnvironmentData);
      document.getElementById('btnStartPolling').addEventListener('click', startSwitchBotPolling);
      document.getElementById('btnOpenMain').addEventListener('click', () => {
        window.open('/', '_blank');
      });

      try {
        await loadReferenceData();
      } catch (error) {
        console.warn('Initial reference data load failed:', error);
      }

      await loadDevices();
      // Disabled auto-refresh to prevent conflicts - use manual refresh instead
      // startAutoRefresh();
    });

    window.addEventListener('beforeunload', () => {
      stopAutoRefresh();
      // Stop any polling intervals
      if (window.switchBotPollingInterval) {
        clearInterval(window.switchBotPollingInterval);
      }
    });

    // Helper functions for device management
    function getDeviceIcon(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      if (type.includes('meter') || type.includes('sensor') || type.includes('monitor')) {
        return 'üå°Ô∏è'; // Sensor/meter devices
      } else if (type.includes('plug') || type.includes('switch')) {
        return 'üîå'; // Plug/switch devices
      } else if (type.includes('bot')) {
        return 'ü§ñ'; // Bot devices
      } else if (type.includes('hub')) {
        return 'üì°'; // Hub devices
      } else if (type.includes('camera')) {
        return 'üìπ'; // Camera devices
      } else if (type.includes('lock')) {
        return 'üîí'; // Lock devices
      } else {
        return 'üì±'; // Generic device
      }
    }

    function getDeviceCategory(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      if (type.includes('meter') || type.includes('sensor') || type.includes('monitor')) {
        return 'Environmental Monitoring';
      } else if (type.includes('plug') || type.includes('switch')) {
        return 'Power Control';
      } else if (type.includes('bot')) {
        return 'Mechanical Control';
      } else if (type.includes('hub')) {
        return 'Central Hub';
      } else {
        return 'Smart Device';
      }
    }

    // Device editing functions
    async function editDeviceName(deviceId) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const currentName = device.displayName || device.deviceName || deviceId;
      const newName = prompt('Enter new device name:', currentName);
      if (!newName || newName === currentName) {
        return;
      }

      try {
        const metadata = await persistDeviceMetadata(device, { name: newName, deviceName: newName });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.displayName = newName;
        }
        renderDevicesFromAPI();
        showInfo(`Updated device name to ${escapeHtml(newName)}.`);
      } catch (error) {
        console.error('Failed to update device name:', error);
        showError(`Failed to update device name: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }

    async function updateDeviceLocation(deviceId, locationValue) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const option = findRoomOption(locationValue);
      const locationName = option ? option.name : '';

      try {
        const metadata = await persistDeviceMetadata(device, {
          room: locationName || null,
          roomName: locationName || null,
          roomId: option ? option.id || option.value : null,
          roomSlug: option ? option.value : null,
          location: locationName || null
        });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.farmLocation = locationName;
        }
        renderDevicesFromAPI();
        const safeDeviceName = escapeHtml(device.displayName || device.deviceName || deviceId);
        if (locationName) {
          showInfo(`Updated location for ${safeDeviceName} to ${escapeHtml(locationName)}.`);
        } else {
          showInfo(`Cleared farm location for ${safeDeviceName}.`);
        }
      } catch (error) {
        console.error('Failed to update device location:', error);
        showError(`Failed to update device location: ${escapeHtml(error.message || 'Unknown error')}`);
        applyMetadataToDevice(device);
        renderDevicesFromAPI();
      }
    }

    async function updateDeviceZone(deviceId, zoneValue) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const option = findZoneOption(zoneValue);
      const zoneName = option ? option.name : '';

      try {
        const metadata = await persistDeviceMetadata(device, {
          zone: zoneName || null,
          zoneName: zoneName || null,
          zoneId: option ? option.id || option.value : null,
          zoneSlug: option ? option.value : null
        });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.zoneName = zoneName;
          device.zoneId = option ? option.value : '';
        }
        renderDevicesFromAPI();
        const safeDeviceName = escapeHtml(device.displayName || device.deviceName || deviceId);
        if (zoneName) {
          showInfo(`Assigned ${safeDeviceName} to ${escapeHtml(zoneName)}.`);
        } else {
          showInfo(`Cleared zone assignment for ${safeDeviceName}.`);
        }
      } catch (error) {
        console.error('Failed to update device zone:', error);
        showError(`Failed to update zone: ${escapeHtml(error.message || 'Unknown error')}`);
        applyMetadataToDevice(device);
        renderDevicesFromAPI();
      }
    }

    async function updateManagedEquipment(deviceId, equipment) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const trimmed = equipment && equipment.trim().length > 0 ? equipment.trim() : '';

      try {
        const metadata = await persistDeviceMetadata(device, {
          managedEquipment: trimmed || null,
          equipment: trimmed || null
        });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.managedEquipment = trimmed;
        }
        renderDevicesFromAPI();
        const safeDeviceName = escapeHtml(device.displayName || device.deviceName || deviceId);
        if (trimmed) {
          showInfo(`Updated managed equipment for ${safeDeviceName}: ${escapeHtml(trimmed)}.`);
        } else {
          showInfo(`Cleared managed equipment for ${safeDeviceName}.`);
        }
      } catch (error) {
        console.error('Failed to update managed equipment:', error);
        showError(`Failed to update managed equipment: ${escapeHtml(error.message || 'Unknown error')}`);
        applyMetadataToDevice(device);
        renderDevicesFromAPI();
      }
    }

    // Rate limiting for API calls
    const lastApiCall = {};
    const API_RATE_LIMIT = 3000; // 3 seconds between calls per device

    async function refreshDeviceData(deviceId) {
      try {
        // Check rate limiting
        const now = Date.now();
        if (lastApiCall[deviceId] && (now - lastApiCall[deviceId]) < API_RATE_LIMIT) {
          showInfo(`‚è≥ Please wait ${Math.ceil((API_RATE_LIMIT - (now - lastApiCall[deviceId])) / 1000)} seconds before refreshing this device again`);
          return;
        }

        lastApiCall[deviceId] = now;
        const targetDevice = devices.find(d => d.deviceId === deviceId);
        const safeDeviceLabel = escapeHtml(targetDevice?.displayName || targetDevice?.deviceName || deviceId);
        showInfo(`üîÑ Refreshing data for ${safeDeviceLabel}...`);

        // Call SwitchBot status API for individual device
        const response = await fetch(`/api/switchbot/devices/${deviceId}/status`);
        const data = await response.json();

        if (data.statusCode === 100) {
          // Update device with fresh data
          const device = targetDevice || devices.find(d => d.deviceId === deviceId);
          if (device) {
            const merged = {
              ...device.lastReading,
              ...data.body,
              lastUpdate: new Date().toISOString()
            };
            if (
              merged.vpd === undefined &&
              typeof merged.temperature === 'number' &&
              typeof merged.humidity === 'number'
            ) {
              const computedVpd = computeVPD(merged.temperature, merged.humidity);
              if (computedVpd !== null) {
                merged.vpd = computedVpd;
              }
            }
            if (merged.weight !== undefined && merged.wattage === undefined) {
              merged.wattage = merged.weight;
            }
            device.lastReading = enrichReading(merged);
            applyMetadataToDevice(device);
            renderDevicesFromAPI();
            const refreshedLabel = escapeHtml(device.displayName || device.deviceName || deviceId);
            showInfo(`‚úÖ Refreshed data for ${refreshedLabel}.`);
          }
        } else {
          throw new Error(data.message || 'Failed to get device status');
        }
      } catch (error) {
        console.error('Device refresh error:', error);
        showError(`Failed to refresh device data: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }

    async function controlDevice(deviceId, command) {
      try {
        const device = devices.find(d => d.deviceId === deviceId);
        const deviceName = device ? device.displayName || device.deviceName : deviceId;
        const safeCommand = escapeHtml(command);
        const safeDeviceName = escapeHtml(deviceName);

        showInfo(`üéÆ Sending ${safeCommand} command to ${safeDeviceName}...`);

        const response = await fetch(`/api/switchbot/devices/${deviceId}/commands`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            command: command,
            parameter: 'default'
          })
        });
        
        const data = await response.json();

        if (data.statusCode === 100) {
          showInfo(`‚úÖ Successfully sent ${safeCommand} command to ${safeDeviceName}.`);
          // Refresh device data after command
          setTimeout(() => refreshDeviceData(deviceId), 2000);
        } else {
          throw new Error(data.message || 'Command failed');
        }
      } catch (error) {
        console.error('Failed to control device:', error);
        showError(`Failed to control device: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }
  </script>
</body>
</html>