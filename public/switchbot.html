<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SwitchBot Device Manager - Light Engine Charlie</title>
  <link rel="stylesheet" href="./styles.charlie.css?v=charlie-0.5">
  <style>
    body {
      margin: 0;
      font-family: var(--gr-font, 'Segoe UI', sans-serif);
      background: var(--gr-bg, #f7fafa);
      color: var(--gr-text, #0b1220);
    }

    .page-container {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .switchbot-header {
      background: linear-gradient(135deg, var(--gr-primary, #0d7d7d), var(--gr-primary-hover, #0c6f6f));
      color: var(--gr-surface, #ffffff);
      padding: 28px;
      border-radius: 20px;
      box-shadow: var(--gr-shadow-lg, 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 10px 10px -5px rgb(0 0 0 / 0.04));
      margin-bottom: 24px;
    }

    .switchbot-header h1 {
      margin: 0;
      font-size: 28px;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .switchbot-header p {
      margin: 12px 0 0;
      font-size: 15px;
      opacity: 0.9;
    }

    .switchbot-header details {
      margin-top: 18px;
      background: rgb(255 255 255 / 0.12);
      border-radius: 14px;
      padding: 12px 16px;
    }

    .switchbot-header summary {
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.02em;
      list-style: none;
    }

    .switchbot-header summary::marker {
      display: none;
    }

    .switchbot-header details[open] summary {
      margin-bottom: 8px;
    }

    .switchbot-header details div {
      font-size: 13px;
      line-height: 1.6;
      color: var(--gr-surface, #ffffff);
      opacity: 0.95;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .section-header h2 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .device-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 20px;
      margin: 20px 0 32px;
    }

    .device-card {
      border: 1px solid var(--gr-border, #dce5e5);
      border-radius: 16px;
      padding: 20px;
      background: var(--gr-surface, #ffffff);
      box-shadow: var(--gr-shadow, 0 8px 16px -8px rgb(15 23 42 / 0.2));
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-height: 220px;
    }

    .device-card:hover {
      transform: translateY(-3px);
      box-shadow: var(--gr-shadow-lg, 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 10px 10px -5px rgb(0 0 0 / 0.04));
    }

    .device-header {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      align-items: flex-start;
    }

    .device-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .device-header .meta {
      font-size: 13px;
      color: #4d5562;
      margin-top: 4px;
    }

    .device-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .device-avatar {
      width: 52px;
      height: 52px;
      border-radius: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 18px;
      background: rgba(13, 125, 125, 0.12);
      color: var(--gr-primary, #0d7d7d);
      border: 1px solid rgba(13, 125, 125, 0.25);
      flex-shrink: 0;
    }

    .device-avatar.tone-energy {
      background: rgba(79, 70, 229, 0.12);
      border-color: rgba(79, 70, 229, 0.25);
      color: #4338ca;
    }

    .device-avatar.tone-safety {
      background: rgba(209, 67, 67, 0.1);
      border-color: rgba(209, 67, 67, 0.25);
      color: #b91c1c;
    }

    .device-avatar.tone-automation {
      background: rgba(240, 165, 0, 0.12);
      border-color: rgba(240, 165, 0, 0.28);
      color: #b45309;
    }

    .control-button {
      padding: 8px 16px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: var(--gr-border, #dce5e5);
      color: var(--gr-text, #0b1220);
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
    }

    .control-button.on {
      background: var(--gr-primary, #0d7d7d);
      color: var(--gr-surface, #ffffff);
      box-shadow: 0 10px 20px -12px var(--gr-primary, #0d7d7d);
    }

    .control-button.off {
      background: var(--gr-surface, #ffffff);
      border-color: var(--gr-border, #dce5e5);
      color: #0f172a;
    }

    .control-button.secondary {
      background: var(--gr-accent-soft, #e9f8f8);
      color: var(--gr-primary, #0d7d7d);
    }

    .control-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px -14px rgb(15 23 42 / 0.35);
    }

    .control-button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .device-status {
      display: inline-flex;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      margin-right: 8px;
      background: var(--gr-border, #dce5e5);
      position: relative;
    }

    .device-status::after {
      content: '';
      position: absolute;
      inset: -3px;
      border-radius: inherit;
      border: 1px solid transparent;
    }

    .status-online {
      background: #0f9b74;
    }

    .status-online::after {
      border-color: rgba(15, 155, 116, 0.35);
    }

    .status-offline {
      background: #d14343;
    }

    .status-offline::after {
      border-color: rgba(209, 67, 67, 0.35);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid transparent;
      background: var(--gr-surface, #ffffff);
      color: var(--gr-text, #0b1220);
      min-width: 70px;
    }

    .status-badge.tone-positive {
      background: rgba(15, 155, 116, 0.12);
      border-color: rgba(15, 155, 116, 0.4);
      color: #0f9b74;
    }

    .status-badge.tone-warning {
      background: rgba(240, 165, 0, 0.12);
      border-color: rgba(240, 165, 0, 0.4);
      color: #b45309;
    }

    .status-badge.tone-critical {
      background: rgba(209, 67, 67, 0.12);
      border-color: rgba(209, 67, 67, 0.45);
      color: #b91c1c;
    }

    .status-badge.tone-neutral {
      background: rgba(79, 70, 229, 0.08);
      border-color: rgba(79, 70, 229, 0.25);
      color: #4338ca;
    }

    .reading-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .reading-item {
      background: var(--gr-primary-soft, #e6f0f0);
      border-radius: 12px;
      border: 1px solid var(--gr-border, #dce5e5);
      padding: 14px 16px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 90px;
    }

    .reading-value {
      font-size: 20px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .reading-label {
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #4d5562;
    }

    .reading-item[data-tone="warning"] {
      background: rgba(240, 165, 0, 0.1);
      border-color: rgba(240, 165, 0, 0.3);
    }

    .reading-item[data-tone="critical"] {
      background: rgba(209, 67, 67, 0.12);
      border-color: rgba(209, 67, 67, 0.35);
    }

    .reading-item[data-tone="positive"] {
      background: rgba(15, 155, 116, 0.1);
      border-color: rgba(15, 155, 116, 0.3);
    }

    .sync-status {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 18px;
      background: var(--gr-surface, #ffffff);
      border-radius: 14px;
      border: 1px solid var(--gr-border, #dce5e5);
      box-shadow: var(--gr-shadow, 0 8px 16px -12px rgb(15 23 42 / 0.3));
      margin-bottom: 24px;
    }

    .sync-indicator {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: var(--gr-primary, #0d7d7d);
      position: relative;
      overflow: hidden;
    }

    .sync-indicator::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      box-shadow: 0 0 0 0 rgba(13, 125, 125, 0.3);
      animation: syncPulse 2s infinite;
    }

    .sync-indicator.error {
      background: #d14343;
    }

    .sync-indicator.error::after {
      animation: none;
      box-shadow: none;
    }

    @keyframes syncPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(13, 125, 125, 0.3);
      }
      70% {
        box-shadow: 0 0 0 6px rgba(13, 125, 125, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(13, 125, 125, 0);
      }
    }

    .error-message {
      background: rgba(209, 67, 67, 0.08);
      border: 1px solid rgba(209, 67, 67, 0.35);
      color: #7f1d1d;
      padding: 16px;
      border-radius: 12px;
      margin: 20px 0;
    }

    .info-message {
      background: rgba(79, 70, 229, 0.08);
      border: 1px solid rgba(79, 70, 229, 0.25);
      color: #312e81;
      padding: 16px;
      border-radius: 12px;
      margin: 20px 0;
    }

    .loading {
      text-align: center;
      padding: 48px;
      color: #4d5562;
      font-size: 15px;
    }

    .device-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .device-summary-item {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--gr-border, #dce5e5);
      background: var(--gr-surface, #ffffff);
      min-width: 140px;
      box-shadow: var(--gr-shadow, 0 8px 16px -14px rgb(15 23 42 / 0.25));
    }

    .device-summary-item.tone-positive {
      border-color: rgba(15, 155, 116, 0.35);
      background: rgba(15, 155, 116, 0.08);
    }

    .device-summary-item.tone-warning {
      border-color: rgba(240, 165, 0, 0.35);
      background: rgba(240, 165, 0, 0.08);
    }

    .device-summary-item.tone-critical {
      border-color: rgba(209, 67, 67, 0.35);
      background: rgba(209, 67, 67, 0.08);
    }

    .device-summary-value {
      font-size: 16px;
      font-weight: 600;
      color: var(--gr-text, #0b1220);
    }

    .device-summary-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #4d5562;
      margin-top: 4px;
    }

    .device-type-badge.real-device {
      background: rgba(15, 155, 116, 0.12);
      color: #0f9b74;
      border: 1px solid rgba(15, 155, 116, 0.3);
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(15, 155, 116, 0.1);
      border: 1px solid rgba(15, 155, 116, 0.3);
      color: #0f9b74;
      font-weight: 600;
    }

    .pulse-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #0f9b74;
      position: relative;
      overflow: hidden;
    }

    .pulse-dot::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      box-shadow: 0 0 0 0 rgba(15, 155, 116, 0.4);
      animation: syncPulse 2s infinite;
    }

    .device-status.online {
      color: #0f9b74;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="page-container">
    <div class="switchbot-header">
      <h1>SwitchBot Device Manager</h1>
      <p>Live monitoring and control of SwitchBot devices with comprehensive data.</p>
      <details>
        <summary>Available Data Fields</summary>
        <div>
          <strong>Environmental:</strong> Temperature, Humidity, CO₂, Light Level, Motion Detection<br>
          <strong>Power:</strong> On/Off Status, Voltage, Current, Daily Usage, Power Consumption<br>
          <strong>Device:</strong> Battery Level, Signal Strength, Firmware Version, Connection Type<br>
          <strong>Management:</strong> Zone Assignment, Farm Location, Equipment Control
        </div>
      </details>
      <details>
        <summary>Control Guardrails</summary>
        <div>
          <strong>North Star:</strong>
          <ul>
            <li>Manage rooms and zones in Farm Setup; device and group cards provide progressively narrower context.</li>
            <li>Typed groups with guardrails prevent lighting plans from colliding with environmental automation.</li>
          </ul>
          <strong>Control Contracts:</strong>
          <ul>
            <li>SwitchBot sensors feed zone targets and control intent via the <code>/env</code> contract.</li>
            <li>Lights follow spectrum plans and schedules from <code>/plans</code> and <code>/sched</code>; avoid mixing plug automation with those payloads.</li>
          </ul>
          <strong>Golden Rules for Plugs:</strong>
          <ol>
            <li>When a light has a direct API, run it through <code>/sched</code> HEX12 payloads and force its plug ON—reserve the plug for emergency kills.</li>
            <li>Gate only non-dimmable or API-less lights with plugs and exclude them from schedule applications.</li>
            <li>Drive dehumidifiers, fans, and heaters through plug or relay automation tied to <code>/env</code> targets, never lighting schedules.</li>
            <li>Set plug-controlled lights to <code>controlPriority: "plug_only"</code> so schedules stay off that circuit.</li>
          </ol>
        </div>
      </details>
    </div>

    <div class="sync-status" id="syncStatus">
      <div class="sync-indicator" id="syncIndicator"></div>
      <span id="syncText">Loading environment data...</span>
      <button id="btnRefresh" type="button" class="ghost" style="margin-left: auto;">Refresh</button>
    </div>

    <div class="section-header">
      <div>
        <h2>SwitchBot Devices</h2>
        <p class="tiny" style="margin: 4px 0 0; color: #64748b;" id="deviceCount">Loading...</p>
      </div>
      <div class="row" style="gap: 8px;">
        <button id="btnStartPolling" type="button" class="primary">Start Polling</button>
        <button id="btnOpenMain" type="button" class="ghost">Back to Dashboard</button>
      </div>
    </div>

    <div id="errorContainer"></div>
    <div id="infoContainer"></div>
    <div id="loadingContainer" class="loading" style="display: none;">
      <div>Loading devices...</div>
    </div>
    
    <div id="devicesContainer" class="device-grid">
      <!-- Devices will be loaded here -->
    </div>
  </div>

  <script>
    let devices = [];
    let syncInterval = null;
    let environmentData = [];
    const deviceMetadataMap = new Map();
    let deviceMetadataLoaded = false;
    let deviceMetadataPromise = null;
    let baseZoneOptions = [];
    let zoneOptionsLocked = false;
    let baseRoomOptions = [];
    let availableZones = [];
    let availableRooms = [];
    const fallbackCounters = { zone: 0, room: 0 };

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function escapeAttribute(value) {
      return escapeHtml(value);
    }

    function slugify(value) {
      return String(value ?? '')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    }

    function nextFallbackValue(prefix) {
      fallbackCounters[prefix] = (fallbackCounters[prefix] || 0) + 1;
      return `${prefix}-${fallbackCounters[prefix]}`;
    }

    const CONTROLLED_TYPE_OPTIONS = ['dehumidifier', 'fan', 'light', 'heater', 'misc'];
    const CRITICALITY_OPTIONS = ['safety', 'comfort', 'optional'];
    const ENERGY_TELEMETRY_OPTIONS = ['plug_builtin', 'branch_meter', 'none'];
    const SENSOR_METRIC_ORDER = ['temp', 'rh', 'co2', 'vpd'];

    function toNumeric(value) {
      if (value === undefined || value === null) return null;
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
      }
      if (typeof value === 'string') {
        const match = value.match(/-?\d+(?:\.\d+)?/);
        if (match) {
          const parsed = Number(match[0]);
          return Number.isFinite(parsed) ? parsed : null;
        }
      }
      return null;
    }

    function coalesceNumeric(...values) {
      for (const candidate of values) {
        const numeric = toNumeric(candidate);
        if (numeric !== null) {
          return numeric;
        }
      }
      return null;
    }

    function clampWeight(value, fallback = null) {
      const numeric = toNumeric(value);
      if (numeric !== null) {
        return Math.max(0, Math.min(1, numeric));
      }
      if (fallback === null || fallback === undefined) {
        return null;
      }
      const fallbackNumeric = toNumeric(fallback);
      return fallbackNumeric === null ? null : Math.max(0, Math.min(1, fallbackNumeric));
    }

    function normalizeSensorMetric(metric) {
      if (!metric && metric !== 0) return null;
      const normalized = String(metric).trim().toLowerCase();
      if (!normalized) return null;
      if (['temp', 'temperature', 'temp_c', 'tempc', 'tempf', 'temp_f'].includes(normalized)) return 'temp';
      if (['humidity', 'rh', 'relative_humidity', 'relative-humidity'].includes(normalized)) return 'rh';
      if (['co2', 'co₂', 'co2ppm', 'co2_ppm', 'carbon_dioxide', 'carbon-dioxide'].includes(normalized)) return 'co2';
      if (['vpd', 'vapour_pressure_deficit', 'vapor_pressure_deficit', 'vapour-pressure-deficit'].includes(normalized)) return 'vpd';
      return null;
    }

    function deriveSensorMetrics(device, metadata) {
      const metrics = new Set();
      const existingMetrics = Array.isArray(device?.metrics) ? device.metrics : [];
      existingMetrics.forEach(metric => {
        const normalized = normalizeSensorMetric(metric);
        if (normalized) metrics.add(normalized);
      });

      const metaDetails = metadata?.details || {};
      const metaMetrics = Array.isArray(metadata?.metrics)
        ? metadata.metrics
        : Array.isArray(metaDetails.metrics)
        ? metaDetails.metrics
        : [];
      metaMetrics.forEach(metric => {
        const normalized = normalizeSensorMetric(metric);
        if (normalized) metrics.add(normalized);
      });

      const reading = device?.lastReading || {};
      const sensorCandidates = [
        reading,
        reading.readings,
        reading.latest,
        reading.metrics,
        reading.sensors
      ];
      sensorCandidates.forEach(source => {
        if (!source || typeof source !== 'object') return;
        const normalizedSource = source;
        if (normalizedSource.temperature !== undefined || normalizedSource.temp !== undefined || normalizedSource.tempC !== undefined) {
          metrics.add('temp');
        }
        if (normalizedSource.humidity !== undefined || normalizedSource.rh !== undefined) {
          metrics.add('rh');
        }
        if (
          normalizedSource.co2 !== undefined ||
          normalizedSource.co2ppm !== undefined ||
          normalizedSource.co2Ppm !== undefined ||
          normalizedSource.co₂ !== undefined
        ) {
          metrics.add('co2');
        }
        if (normalizedSource.vpd !== undefined) {
          metrics.add('vpd');
        }
        if (normalizedSource.tempC && (normalizedSource.tempC.current !== undefined || normalizedSource.tempC.value !== undefined)) {
          metrics.add('temp');
        }
        if (normalizedSource.rh && (normalizedSource.rh.current !== undefined || normalizedSource.rh.value !== undefined)) {
          metrics.add('rh');
        }
        if (normalizedSource.co2 && (normalizedSource.co2.current !== undefined || normalizedSource.co2.value !== undefined)) {
          metrics.add('co2');
        }
        if (normalizedSource.vpd && (normalizedSource.vpd.current !== undefined || normalizedSource.vpd.value !== undefined)) {
          metrics.add('vpd');
        }
      });

      return SENSOR_METRIC_ORDER.filter(metric => metrics.has(metric));
    }

    function normalizeControlledType(value) {
      if (!value && value !== 0) return null;
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) return null;
      if (CONTROLLED_TYPE_OPTIONS.includes(normalized)) return normalized;
      if (normalized.includes('dehum')) return 'dehumidifier';
      if (normalized.includes('fan')) return 'fan';
      if (normalized.includes('light') || normalized.includes('lamp') || normalized.includes('grow')) return 'light';
      if (normalized.includes('heat')) return 'heater';
      return null;
    }

    function normalizeCriticality(value) {
      if (!value && value !== 0) return null;
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) return null;
      if (CRITICALITY_OPTIONS.includes(normalized)) return normalized;
      if (normalized.includes('safety') || normalized.includes('critical')) return 'safety';
      if (normalized.includes('comfort') || normalized.includes('climate')) return 'comfort';
      return null;
    }

    function normalizeEnergyTelemetry(value) {
      if (!value && value !== 0) return null;
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) return null;
      if (ENERGY_TELEMETRY_OPTIONS.includes(normalized)) return normalized;
      if (normalized.includes('branch')) return 'branch_meter';
      if (normalized.includes('builtin') || normalized.includes('built-in') || normalized.includes('plug')) return 'plug_builtin';
      if (normalized.includes('none') || normalized.includes('n/a') || normalized.includes('na')) return 'none';
      return null;
    }

    function guessPlugControlledType(device, metadata) {
      const metaDetails = metadata?.details || {};
      const fromMeta = normalizeControlledType(
        metadata?.controlledType ||
          metaDetails.controlledType ||
          metaDetails.equipmentCategory ||
          metadata?.equipmentCategory
      );
      if (fromMeta) return fromMeta;
      const context = [
        device?.managedEquipment,
        metaDetails.managedEquipment,
        metaDetails.equipment,
        metadata?.managedEquipment,
        device?.displayName,
        device?.deviceName,
        device?.deviceType
      ]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      if (context.includes('dehum')) return 'dehumidifier';
      if (context.includes('fan')) return 'fan';
      if (context.includes('light') || context.includes('lamp') || context.includes('grow')) return 'light';
      if (context.includes('heat') || context.includes('heater')) return 'heater';
      return 'misc';
    }

    function guessPlugCriticality(device, controlledType, metadata) {
      const metaDetails = metadata?.details || {};
      const fromMeta = normalizeCriticality(metadata?.criticality || metaDetails.criticality);
      if (fromMeta) return fromMeta;
      const context = [
        device?.managedEquipment,
        metaDetails.managedEquipment,
        metadata?.managedEquipment,
        device?.displayName,
        device?.deviceName,
        device?.deviceType
      ]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      if (
        context.includes('alarm') ||
        context.includes('security') ||
        context.includes('safety') ||
        context.includes('pump') ||
        context.includes('irrigation')
      ) {
        return 'safety';
      }
      if (controlledType === 'dehumidifier' || controlledType === 'fan' || controlledType === 'heater') {
        return 'comfort';
      }
      return 'optional';
    }

    function guessEnergyTelemetry(device, metadata) {
      const metaDetails = metadata?.details || {};
      const fromMeta = normalizeEnergyTelemetry(
        metadata?.energyTelemetry ||
          metaDetails.energyTelemetry ||
          metaDetails.energySource ||
          metadata?.energySource
      );
      if (fromMeta) return fromMeta;
      const reading = device?.lastReading || {};
      if (
        reading.wattage !== undefined ||
        reading.weight !== undefined ||
        reading.power !== undefined ||
        reading.electricityOfDay !== undefined ||
        reading.voltage !== undefined ||
        reading.electricCurrent !== undefined
      ) {
        return 'plug_builtin';
      }
      return 'none';
    }

    function buildPlacementEntry(option, fallbackLabel) {
      if (option) {
        return {
          id: option.id || null,
          name: option.name,
          value: option.value || option.id || null,
          source: 'farm'
        };
      }
      if (fallbackLabel) {
        return {
          id: null,
          name: fallbackLabel,
          value: null,
          source: 'unmapped'
        };
      }
      return null;
    }

    function buildPlacement(device, metadata) {
      const metaDetails = metadata?.details || {};
      const zoneCandidates = [
        device?.zoneId,
        metadata?.zoneId,
        metaDetails.zoneId,
        metadata?.zoneSlug,
        metaDetails.zoneSlug
      ];
      let zoneOption = null;
      for (const candidate of zoneCandidates) {
        zoneOption = findZoneOption(candidate);
        if (zoneOption) break;
      }
      const zoneLabelCandidates = [
        device?.zoneName,
        metadata?.zoneName,
        metadata?.zone,
        metaDetails.zoneName,
        metaDetails.zone,
        device?.lastReading?.zone,
        device?.lastReading?.name
      ];
      const zoneLabel = zoneLabelCandidates.find(label => typeof label === 'string' && label.trim());
      const zonePlacement = buildPlacementEntry(zoneOption, zoneLabel);

      const roomCandidates = [
        device?.farmLocationId,
        metadata?.roomId,
        metaDetails.roomId,
        metadata?.roomSlug,
        metaDetails.roomSlug
      ];
      let roomOption = null;
      for (const candidate of roomCandidates) {
        roomOption = findRoomOption(candidate);
        if (roomOption) break;
      }
      const roomLabelCandidates = [
        device?.farmLocation,
        metadata?.roomName,
        metadata?.room,
        metadata?.location,
        metaDetails.roomName,
        metaDetails.room,
        device?.lastReading?.location
      ];
      const roomLabel = roomLabelCandidates.find(label => typeof label === 'string' && label.trim());
      const roomPlacement = buildPlacementEntry(roomOption, roomLabel);

      const level = metaDetails.level || metaDetails.rackLevel || metaDetails.tier || metaDetails.shelf || metadata?.level || device?.placement?.level || null;
      const side = metaDetails.side || metaDetails.orientation || metaDetails.aisle || metadata?.side || device?.placement?.side || null;

      return {
        zone: zonePlacement,
        room: roomPlacement,
        level: level || null,
        side: side || null
      };
    }

    function deriveRole(device, metadata) {
      const metaDetails = metadata?.details || {};
      const candidate = (metadata?.role || metaDetails.role || '').toLowerCase();
      if (candidate === 'sensor') return 'sensor';
      if (candidate === 'plug' || candidate === 'actuator' || candidate === 'switch') return 'plug';
      return isSensorDevice(device?.deviceType) ? 'sensor' : 'plug';
    }

    function syncDeviceCardSchema(device, metadata) {
      if (!device) return;
      const canonicalId = getCanonicalDeviceId(device) || device.deviceId || device.device_id || '';
      if (!device.deviceId) {
        device.deviceId = canonicalId;
      }
      const reading = device.lastReading || {};
      const metaDetails = metadata?.details || {};
      const batteryLevel = coalesceNumeric(
        reading.battery,
        reading.meta?.battery,
        reading.version?.battery,
        device.battery,
        metaDetails.battery,
        device.identity?.battery
      );
      const signalLevel = coalesceNumeric(
        reading.rssi,
        reading.meta?.rssi,
        reading.signal,
        reading.version?.rssi,
        device.rssi,
        metaDetails.signal,
        device.identity?.signal
      );
      const displayName =
        device.displayName ||
        metadata?.name ||
        metadata?.deviceName ||
        metaDetails.displayName ||
        device.deviceName ||
        device.name ||
        canonicalId;

      device.identity = {
        deviceId: canonicalId,
        name: displayName,
        battery: batteryLevel,
        signal: signalLevel
      };

      device.placement = buildPlacement(device, metadata);

      const role = deriveRole(device, metadata);
      device.role = role;

      if (role === 'sensor') {
        device.metrics = deriveSensorMetrics(device, metadata);
        const weightFromMeta = clampWeight(metaDetails.weight ?? metadata?.weight, null);
        const existingWeight = clampWeight(device.weight, null);
        device.weight = weightFromMeta ?? existingWeight ?? null;
        if (metaDetails.primary !== undefined || metadata?.primary !== undefined) {
          device.primary = Boolean(metaDetails.primary ?? metadata?.primary);
        } else if (device.primary === undefined) {
          device.primary = false;
        } else {
          device.primary = Boolean(device.primary);
        }
        delete device.controlledType;
        delete device.criticality;
        delete device.controlMethod;
        delete device.energyTelemetry;
        delete device.controlPriority;
      } else {
        delete device.metrics;
        delete device.weight;
        delete device.primary;
        delete device.controlPriority;
        const controlledType = guessPlugControlledType(device, metadata);
        device.controlledType = controlledType;
        device.criticality = guessPlugCriticality(device, controlledType, metadata);
        device.controlMethod = 'plug_onoff';
        device.energyTelemetry = guessEnergyTelemetry(device, metadata);
        if (controlledType === 'light') {
          device.controlPriority = 'plug_only';
        }
      }
    }

    function recalculateSensorWeights() {
      const sensorsByZone = new Map();
      devices.forEach(device => {
        if (!device || device.role !== 'sensor') return;
        const zoneKey =
          (device.placement && device.placement.zone && device.placement.zone.value) ||
          device.zoneId ||
          (device.placement && device.placement.zone && device.placement.zone.name) ||
          '__unassigned__';
        if (!sensorsByZone.has(zoneKey)) {
          sensorsByZone.set(zoneKey, []);
        }
        sensorsByZone.get(zoneKey).push(device);
      });

      sensorsByZone.forEach(devicesInZone => {
        if (!devicesInZone.length) return;
        const explicitPrimary = devicesInZone.filter(device => device.primary === true);
        if (explicitPrimary.length === 0) {
          let chosen = devicesInZone[0];
          let highestBattery = -Infinity;
          devicesInZone.forEach(device => {
            const battery = toNumeric(device.identity?.battery ?? device.lastReading?.battery);
            if (battery !== null && battery > highestBattery) {
              highestBattery = battery;
              chosen = device;
            }
          });
          devicesInZone.forEach(device => {
            device.primary = device === chosen;
          });
        } else {
          devicesInZone.forEach(device => {
            device.primary = explicitPrimary.includes(device);
          });
        }

        const explicitWeights = devicesInZone.filter(device => device.weight !== null && device.weight !== undefined);
        if (explicitWeights.length === devicesInZone.length) {
          devicesInZone.forEach(device => {
            device.weight = clampWeight(device.weight, 0);
          });
        } else {
          const defaultWeight = devicesInZone.length > 0 ? clampWeight(1 / devicesInZone.length, 0) : 0;
          devicesInZone.forEach(device => {
            if (device.weight === null || device.weight === undefined) {
              device.weight = defaultWeight;
            } else {
              device.weight = clampWeight(device.weight, defaultWeight);
            }
          });
        }
      });
    }

    function createOption(id, name, prefix) {
      const trimmedName = typeof name === 'string' ? name.trim() : '';
      const trimmedId = typeof id === 'string' ? id.trim() : '';
      const displayName = trimmedName || trimmedId;
      if (!displayName) return null;
      let value = trimmedId;
      if (!value) {
        const slug = slugify(displayName);
        value = slug ? `${prefix}-${slug}` : nextFallbackValue(prefix);
      }
      return {
        id: trimmedId || null,
        name: displayName,
        value
      };
    }

    function normalizeZoneOption(zone, index = 0) {
      if (!zone) return null;
      if (typeof zone === 'string') {
        return createOption(null, zone, 'zone');
      }
      if (typeof zone === 'object') {
        const source = zone;
        const id = source.id || source.zoneId || source.zone_id || source.zone || source.identifier || null;
        const name = source.name || source.displayName || source.label || source.zone || source.location || id || `Zone ${index + 1}`;
        return createOption(id, name, 'zone');
      }
      return null;
    }

    function normalizeRoomOption(room, index = 0) {
      if (!room) return null;
      if (typeof room === 'string') {
        return createOption(null, room, 'room');
      }
      if (typeof room === 'object') {
        const source = room;
        const id = source.id || source.roomId || source.room_id || source.identifier || null;
        const name = source.name || source.label || source.title || source.roomName || source.location || id || `Room ${index + 1}`;
        return createOption(id, name, 'room');
      }
      return null;
    }

    function dedupeAndSortOptions(options) {
      const map = new Map();
      (options || []).forEach(option => {
        if (!option || !option.value) return;
        if (!map.has(option.value)) {
          map.set(option.value, option);
        } else {
          const existing = map.get(option.value);
          if (!existing.name && option.name) {
            map.set(option.value, option);
          }
        }
      });
      return Array.from(map.values()).sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
      );
    }

    function findOption(list, value) {
      if (!value) return null;
      const normalized = String(value).trim();
      if (!normalized) return null;
      return (list || []).find(
        option =>
          option.value === normalized ||
          option.id === normalized ||
          option.name === normalized
      ) || null;
    }

    function setBaseZoneOptions(options, { lock = false, merge = false } = {}) {
      const normalized = dedupeAndSortOptions(options || []);
      if (merge && baseZoneOptions.length > 0) {
        baseZoneOptions = dedupeAndSortOptions([...baseZoneOptions, ...normalized]);
      } else if (zoneOptionsLocked && !lock) {
        if (merge) {
          baseZoneOptions = dedupeAndSortOptions([...baseZoneOptions, ...normalized]);
        } else if (baseZoneOptions.length === 0) {
          baseZoneOptions = normalized;
        }
      } else {
        baseZoneOptions = normalized;
      }
      if (lock && normalized.length > 0) {
        zoneOptionsLocked = true;
      }
      rebuildZoneOptions();
    }

    function setBaseRoomOptions(options) {
      baseRoomOptions = dedupeAndSortOptions(options || []);
      rebuildRoomOptions();
    }

    function extractZoneOptionsFromMetadata(meta) {
      if (!meta || typeof meta !== 'object') return [];
      const details = meta.details || {};
      const candidates = [
        createOption(details.zoneId || details.zoneSlug || null, details.zoneName || details.zone, 'zone'),
        createOption(meta.zoneId || meta.zoneSlug || null, meta.zoneName || meta.zone, 'zone'),
        createOption(null, meta.zone, 'zone')
      ];
      return candidates.filter(Boolean);
    }

    function extractRoomOptionsFromMetadata(meta) {
      if (!meta || typeof meta !== 'object') return [];
      const details = meta.details || {};
      const assigned = meta.assignedEquipment || {};
      const candidates = [
        createOption(details.roomId || details.roomSlug || null, details.roomName || details.room || details.location, 'room'),
        createOption(meta.roomId || meta.roomSlug || null, meta.roomName || meta.room || meta.location, 'room'),
        createOption(assigned.roomId || null, assigned.roomName || assigned.room || null, 'room')
      ];
      const enriched = candidates
        .filter(Boolean)
        .map(option => {
          if (option && option.id && !option.name) {
            const match = findOption(baseRoomOptions, option.id);
            if (match) {
              return createOption(match.id, match.name, 'room');
            }
          }
          return option;
        });
      return enriched.filter(Boolean);
    }

    function rebuildZoneOptions() {
      const combined = [...baseZoneOptions];
      deviceMetadataMap.forEach(meta => {
        combined.push(...extractZoneOptionsFromMetadata(meta));
      });
      availableZones = dedupeAndSortOptions(combined);
    }

    function rebuildRoomOptions() {
      const combined = [...baseRoomOptions];
      deviceMetadataMap.forEach(meta => {
        combined.push(...extractRoomOptionsFromMetadata(meta));
      });
      availableRooms = dedupeAndSortOptions(combined);
    }

    function findZoneOption(value) {
      return findOption(availableZones, value) || findOption(baseZoneOptions, value);
    }

    function findRoomOption(value) {
      return findOption(availableRooms, value) || findOption(baseRoomOptions, value);
    }

    function getCanonicalDeviceId(source) {
      if (!source || typeof source !== 'object') return '';
      const candidate =
        source.device_id ??
        source.deviceId ??
        source.id ??
        source.uuid ??
        source.deviceID ??
        source.macAddress ??
        '';
      return typeof candidate === 'string'
        ? candidate.trim()
        : String(candidate || '').trim();
    }

    function normalizeMetadata(raw) {
      if (!raw || typeof raw !== 'object') return null;
      return { ...raw };
    }

    function storeDeviceMetadata(raw) {
      const normalized = normalizeMetadata(raw);
      if (!normalized) return null;
      const id = getCanonicalDeviceId(normalized);
      if (!id) return null;
      normalized.device_id = id;
      deviceMetadataMap.set(id.toLowerCase(), normalized);
      return normalized;
    }

    function getDeviceMetadata(deviceId) {
      const key =
        typeof deviceId === 'string'
          ? deviceId.trim()
          : String(deviceId || '').trim();
      if (!key) return null;
      return deviceMetadataMap.get(key.toLowerCase()) || null;
    }

    function getZoneSelection(metadata, device) {
      const candidates = [];
      if (metadata && typeof metadata === 'object') {
        const details = metadata.details || {};
        candidates.push({ value: details.zoneSlug, label: details.zoneName || details.zone });
        candidates.push({ value: details.zoneId, label: details.zoneName || details.zone });
        candidates.push({ value: metadata.zoneSlug, label: metadata.zoneName });
        candidates.push({ value: metadata.zoneId, label: metadata.zoneName });
        candidates.push({ value: metadata.zone, label: metadata.zone });
      }
      if (device && typeof device === 'object') {
        candidates.push({ value: device.zoneId, label: device.zoneName });
        candidates.push({ value: device.zone, label: device.zoneName || device.zone });
      }
      for (const candidate of candidates) {
        if (!candidate) continue;
        const { value, label } = candidate;
        if (value) {
          const option = findZoneOption(value) || findZoneOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
          return {
            value: String(value).trim(),
            label: label ? String(label).trim() : String(value).trim()
          };
        }
        if (label) {
          const option = findZoneOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
        }
      }
      return { value: '', label: '' };
    }

    function getRoomSelection(metadata, device) {
      const candidates = [];
      if (metadata && typeof metadata === 'object') {
        const details = metadata.details || {};
        const assigned = metadata.assignedEquipment || {};
        candidates.push({ value: details.roomSlug, label: details.roomName || details.room || details.location });
        candidates.push({ value: details.roomId, label: details.roomName || details.room || details.location });
        candidates.push({ value: metadata.roomSlug, label: metadata.roomName || metadata.room || metadata.location });
        candidates.push({ value: metadata.roomId, label: metadata.roomName || metadata.room || metadata.location });
        candidates.push({ value: assigned.roomId, label: assigned.roomName || assigned.room });
        candidates.push({ value: metadata.location, label: metadata.location });
      }
      if (device && typeof device === 'object') {
        candidates.push({ value: device.farmLocationId, label: device.farmLocation });
        candidates.push({ value: device.farmLocation, label: device.farmLocation });
      }
      for (const candidate of candidates) {
        if (!candidate) continue;
        const { value, label } = candidate;
        if (value) {
          const option = findRoomOption(value) || findRoomOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
          return {
            value: String(value).trim(),
            label: label ? String(label).trim() : String(value).trim()
          };
        }
        if (label) {
          const option = findRoomOption(label);
          if (option) {
            return { value: option.value, label: option.name };
          }
        }
      }
      return { value: '', label: '' };
    }

    function computeVPD(tempC, humidityPercent) {
      const temp = Number(tempC);
      const rh = Number(humidityPercent);
      if (!Number.isFinite(temp) || !Number.isFinite(rh)) return null;
      const clampedRh = Math.min(Math.max(rh, 0), 100);
      const saturationVaporPressure = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));
      const deficit = saturationVaporPressure * (1 - clampedRh / 100);
      const rounded = Math.round(deficit * 100) / 100;
      return Number.isFinite(rounded) ? rounded : null;
    }

    function formatNumber(value, decimals = 1) {
      const num = Number(value);
      if (!Number.isFinite(num)) return String(value);
      const fixed = num.toFixed(decimals);
      return fixed.replace(/\.0+$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
    }

    function getPowerState(reading = {}) {
      if (!reading || typeof reading !== 'object') return null;
      const candidates = [
        reading.power,
        reading.powerState,
        reading.powerStatus,
        reading.switch,
        reading.switchStatus,
        reading.status,
        reading.state
      ];
      for (const candidate of candidates) {
        if (candidate === undefined || candidate === null) continue;
        if (typeof candidate === 'string') {
          const normalized = candidate.trim().toLowerCase();
          if (normalized === 'on' || normalized === 'open' || normalized === 'true') return 'on';
          if (normalized === 'off' || normalized === 'closed' || normalized === 'false') return 'off';
        } else if (typeof candidate === 'boolean') {
          return candidate ? 'on' : 'off';
        } else if (typeof candidate === 'number') {
          if (candidate === 1) return 'on';
          if (candidate === 0) return 'off';
          return candidate > 0 ? 'on' : 'off';
        }
      }
      return null;
    }

    function getBatteryTone(level) {
      const numeric = Number(level);
      if (!Number.isFinite(numeric)) return 'neutral';
      if (numeric >= 70) return 'positive';
      if (numeric >= 30) return 'warning';
      return 'critical';
    }

    function formatBatteryLabel(level) {
      const numeric = Number(level);
      if (!Number.isFinite(numeric)) return 'Battery';
      if (numeric >= 70) return 'Battery Good';
      if (numeric >= 30) return 'Battery Low';
      return 'Battery Critical';
    }

    function isPlugDevice(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      return type.includes('plug') || type.includes('outlet') || type.includes('switch');
    }

    function isSensorDevice(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      return (
        type.includes('sensor') ||
        type.includes('meter') ||
        type.includes('monitor') ||
        type.includes('woiosensor')
      );
    }

    function enrichReading(reading) {
      if (!reading || typeof reading !== 'object') return reading;
      const enriched = { ...reading };
      if (
        enriched.vpd === undefined &&
        typeof enriched.temperature === 'number' &&
        typeof enriched.humidity === 'number'
      ) {
        const computed = computeVPD(enriched.temperature, enriched.humidity);
        if (computed !== null) {
          enriched.vpd = computed;
        }
      }
      if (enriched.weight !== undefined && enriched.wattage === undefined) {
        enriched.wattage = enriched.weight;
      }
      return enriched;
    }

    function enrichDeviceReading(device) {
      if (device && device.lastReading) {
        device.lastReading = enrichReading(device.lastReading);
      }
    }

    function applyMetadataToDevice(device, metadataOverride, options = {}) {
      if (!device) return;
      const metadata = metadataOverride || getDeviceMetadata(getCanonicalDeviceId(device));
      enrichDeviceReading(device);
      if (metadata) {
        const nameFromMeta =
          metadata.name ||
          metadata.deviceName ||
          (metadata.details && (metadata.details.displayName || metadata.details.name));
        if (nameFromMeta) {
          device.displayName = nameFromMeta;
        }
        const zoneSelection = getZoneSelection(metadata, device);
        device.zoneId = zoneSelection.value || '';
        device.zoneName = zoneSelection.label || '';
        const roomSelection = getRoomSelection(metadata, device);
        device.farmLocationId = roomSelection.value || '';
        device.farmLocation = roomSelection.label || '';
        const metadataDetails = metadata.details || {};
        const managed =
          metadataDetails.managedEquipment ??
          metadata.managedEquipment ??
          device.managedEquipment ??
          '';
        device.managedEquipment = managed || '';
      } else {
        if (!device.displayName) {
          device.displayName = device.deviceName || device.device_id || device.deviceId;
        }
      }
      syncDeviceCardSchema(device, metadata);
      if (!options.skipRecalculate) {
        recalculateSensorWeights();
      }
    }

    function applyMetadataToAllDevices() {
      devices.forEach(device => {
        applyMetadataToDevice(device, undefined, { skipRecalculate: true });
      });
      recalculateSensorWeights();
    }

    function renderSelectOptions(options, selectedValue, selectedLabel, placeholder) {
      const normalizedSelected = selectedValue ? String(selectedValue).trim() : '';
      const html = [
        `<option value=""${normalizedSelected ? '' : ' selected'}>${escapeHtml(placeholder)}</option>`
      ];
      let hasSelected = false;
      (options || []).forEach(option => {
        if (!option || !option.value) return;
        const isSelected = normalizedSelected && option.value === normalizedSelected;
        if (isSelected) hasSelected = true;
        html.push(
          `<option value="${escapeAttribute(option.value)}"${isSelected ? ' selected' : ''}>${escapeHtml(option.name)}</option>`
        );
      });
      if (normalizedSelected && !hasSelected) {
        html.push(
          `<option value="${escapeAttribute(normalizedSelected)}" selected>${escapeHtml(selectedLabel || normalizedSelected)}</option>`
        );
      }
      return html.join('');
    }

    function createDeviceSummary(device, reading) {
      if (!device || !reading || typeof reading !== 'object') return '';
      const type = String(device.deviceType || '').toLowerCase();
      const items = [];

      if (isPlugDevice(type)) {
        const state = getPowerState(reading);
        if (state) {
          items.push({
            label: 'Status',
            value: state.toUpperCase(),
            tone: state === 'on' ? 'positive' : 'critical'
          });
        }
        if (reading.wattage !== undefined) {
          items.push({ label: 'Wattage', value: `${formatNumber(reading.wattage, 1)} W` });
        }
        if (reading.voltage !== undefined) {
          items.push({ label: 'Voltage', value: `${formatNumber(reading.voltage, 1)} V` });
        }
        if (reading.electricCurrent !== undefined) {
          items.push({ label: 'Current', value: `${formatNumber(reading.electricCurrent, 2)} A` });
        }
      } else if (isSensorDevice(type)) {
        if (reading.temperature !== undefined) {
          items.push({ label: 'Temperature', value: `${formatNumber(reading.temperature, 1)} °C` });
        }
        if (reading.humidity !== undefined) {
          items.push({ label: 'Humidity', value: `${formatNumber(reading.humidity, 1)} %` });
        }
        const vpdValue = reading.vpd ?? computeVPD(reading.temperature, reading.humidity);
        if (vpdValue !== null && vpdValue !== undefined) {
          items.push({ label: 'VPD', value: `${formatNumber(vpdValue, 2)} kPa` });
        }
        if (reading.battery !== undefined) {
          items.push({
            label: 'Battery',
            value: `${formatNumber(reading.battery, 0)}%`,
            tone: getBatteryTone(reading.battery)
          });
        }
      }

      if (!items.length) return '';

      const chips = items
        .map(item => {
          const toneClass = item.tone ? ` tone-${item.tone}` : '';
          return `
          <div class="device-summary-item${toneClass}">
            <div class="device-summary-value">${escapeHtml(item.value)}</div>
            <div class="device-summary-label">${escapeHtml(item.label)}</div>
          </div>
        `;
        })
        .join('');
      return `<div class="device-summary">${chips}</div>`;
    }

    async function fetchEnvironmentData() {
      try {
        // Try multiple data sources for SwitchBot data
        const dataSources = [
          '/env',  // Local environment endpoint
          '/api/azure/telemetry',  // Azure telemetry API
          '/api/azure/iot-hub'     // Azure IoT Hub data
        ];
        
        for (const source of dataSources) {
          try {
            const response = await fetch(source);
            if (response.ok) {
              const data = await response.json();
              console.log(`Successfully fetched data from ${source}`);
              return data.zones || data.devices || data || [];
            }
          } catch (error) {
            console.warn(`Failed to fetch from ${source}:`, error.message);
          }
        }
        
        throw new Error('No data sources available');
      } catch (error) {
        console.error('Environment API Error:', error);
        throw error;
      }
    }

    async function ensureEnvironmentData(force = false) {
      const hadData = Array.isArray(environmentData) && environmentData.length > 0;
      if (!force && hadData) {
        return environmentData;
      }

      try {
        const data = await fetchEnvironmentData();
        const normalized = Array.isArray(data) ? data : [];
        environmentData = normalized;
        const zoneOptions = normalized
          .map((zone, index) => normalizeZoneOption(zone, index))
          .filter(Boolean);
        setBaseZoneOptions(zoneOptions, { merge: true });
        return environmentData;
      } catch (error) {
        if (!hadData) {
          environmentData = [];
          setBaseZoneOptions([]);
        }
        throw error;
      }
    }

    function collectFarmLayoutEntities(payload, rooms = [], zones = []) {
      if (!payload) return;
      if (Array.isArray(payload)) {
        payload.forEach(item => collectFarmLayoutEntities(item, rooms, zones));
        return;
      }
      if (typeof payload !== 'object') {
        return;
      }

      const roomCandidates = [];
      if (Array.isArray(payload.rooms)) roomCandidates.push(...payload.rooms);
      else if (payload.rooms && typeof payload.rooms === 'object') roomCandidates.push(payload.rooms);
      if (typeof payload.room === 'string' || typeof payload.room === 'object') {
        roomCandidates.push(payload.room);
      }

      roomCandidates.forEach(room => {
        const roomOption = normalizeRoomOption(room, rooms.length);
        if (roomOption) {
          rooms.push(roomOption);
        }
        if (room && typeof room === 'object') {
          const nestedZones = Array.isArray(room.zones) ? room.zones : [];
          nestedZones.forEach(zone => {
            const zoneOption = normalizeZoneOption(zone, zones.length);
            if (zoneOption) zones.push(zoneOption);
          });
          if (Array.isArray(room.children)) {
            room.children.forEach(child => collectFarmLayoutEntities(child, rooms, zones));
          }
        }
      });

      const zoneCandidates = [];
      if (Array.isArray(payload.zones)) zoneCandidates.push(...payload.zones);
      else if (payload.zones && typeof payload.zones === 'object') zoneCandidates.push(payload.zones);
      if (typeof payload.zone === 'string' || typeof payload.zone === 'object') {
        zoneCandidates.push(payload.zone);
      }

      zoneCandidates.forEach(zone => {
        const zoneOption = normalizeZoneOption(zone, zones.length);
        if (zoneOption) {
          zones.push(zoneOption);
        }
      });

      const nestedLayouts = [payload.layout, payload.farm, payload.greenhouse, payload.facility]
        .filter(section => section && typeof section === 'object');
      nestedLayouts.forEach(section => collectFarmLayoutEntities(section, rooms, zones));
    }

    async function fetchFarmLayout() {
      const rooms = [];
      const zones = [];
      const sources = ['/farm', '/data/farm.json', '/data/rooms.json'];

      for (const source of sources) {
        try {
          const response = await fetch(source);
          if (!response.ok) continue;
          const data = await response.json();
          if (!data) continue;
          if (source.endsWith('rooms.json')) {
            const rawRooms = Array.isArray(data?.rooms) ? data.rooms : [];
            rawRooms.forEach(room => {
              const option = normalizeRoomOption(room, rooms.length);
              if (option) rooms.push(option);
            });
          } else if (Array.isArray(data)) {
            data.forEach(entry => collectFarmLayoutEntities(entry, rooms, zones));
          } else {
            collectFarmLayoutEntities(data, rooms, zones);
          }
        } catch (error) {
          console.warn(`Failed to load farm layout from ${source}:`, error);
        }
      }

      if (rooms.length > 0) {
        setBaseRoomOptions(rooms);
      }
      if (zones.length > 0) {
        setBaseZoneOptions(zones, { lock: true });
      }

      return { rooms, zones };
    }

    async function fetchDeviceMetadata() {
      try {
        const response = await fetch('/devices');
        if (!response.ok) {
          throw new Error(`Failed to load device metadata (${response.status})`);
        }
        const payload = await response.json();
        const list = Array.isArray(payload?.devices)
          ? payload.devices
          : Array.isArray(payload)
          ? payload
          : [];

        deviceMetadataMap.clear();
        list.forEach(item => {
          storeDeviceMetadata(item);
        });
        rebuildZoneOptions();
        rebuildRoomOptions();
        deviceMetadataLoaded = true;
        return list;
      } catch (error) {
        console.warn('Failed to load device metadata:', error);
        deviceMetadataLoaded = false;
        return [];
      }
    }

    async function loadDeviceMetadataIfNeeded(force = false) {
      if (!force && deviceMetadataLoaded && deviceMetadataMap.size > 0) {
        return;
      }
      if (deviceMetadataPromise) {
        await deviceMetadataPromise;
        return;
      }
      deviceMetadataPromise = fetchDeviceMetadata().finally(() => {
        deviceMetadataPromise = null;
      });
      await deviceMetadataPromise;
    }

    async function loadReferenceData() {
      await Promise.all([
        ensureEnvironmentData().catch(error => {
          console.warn('Environment data unavailable:', error);
          return [];
        }),
        fetchFarmLayout().catch(error => {
          console.warn('Farm layout unavailable:', error);
          return { rooms: [], zones: [] };
        }),
        (async () => {
          try {
            await loadDeviceMetadataIfNeeded();
          } catch (error) {
            console.warn('Device metadata unavailable:', error);
          }
        })()
      ]);

      applyMetadataToAllDevices();
    }

    function sanitizeMetadataPayload(updates = {}) {
      const result = {};
      Object.entries(updates).forEach(([key, value]) => {
        if (value === undefined) {
          return;
        }
        if (value === '') {
          result[key] = null;
          return;
        }
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          result[key] = { ...value };
        } else {
          result[key] = value;
        }
      });
      return result;
    }

    async function fetchJson(url, options = {}) {
      const response = await fetch(url, options);
      const text = await response.text();
      let data = null;
      if (text) {
        try {
          data = JSON.parse(text);
        } catch (error) {
          data = null;
        }
      }
      return { response, data };
    }

    async function persistDeviceMetadata(device, updates = {}) {
      const deviceId = getCanonicalDeviceId(device);
      if (!deviceId) {
        throw new Error('Unable to determine device id for metadata update');
      }

      const payload = sanitizeMetadataPayload(updates);
      let result = await fetchJson(`/devices/${encodeURIComponent(deviceId)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (result.response.status === 404) {
        const createPayload = sanitizeMetadataPayload({
          id: deviceId,
          protocol: 'switchbot',
          category: device?.deviceType || 'SwitchBot Device',
          name: device?.displayName || device?.deviceName || deviceId,
          deviceName: device?.displayName || device?.deviceName || deviceId,
          manufacturer: 'SwitchBot',
          model: device?.deviceType || device?.deviceName || 'SwitchBot',
          ...updates
        });
        result = await fetchJson('/devices', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(createPayload)
        });
      }

      const { response, data } = result;
      if (!response.ok) {
        const message = (data && (data.error || data.message)) || `Request failed with status ${response.status}`;
        const error = new Error(message);
        error.status = response.status;
        error.data = data;
        throw error;
      }

      const saved = data && (data.device || data);
      if (saved) {
        const normalized = storeDeviceMetadata(saved);
        rebuildZoneOptions();
        rebuildRoomOptions();
        return normalized || saved;
      }

      return saved;
    }

    async function fetchSwitchBotDevices() {
      try {
        // Fetch real SwitchBot devices from your farm
        const response = await fetch('/api/switchbot/devices');
        if (response.status === 429) {
          throw new Error('SwitchBot API rate limit reached. Please wait before making more requests.');
        }
        
        const data = await response.json();
        
        if (data.statusCode !== 100) {
          throw new Error(`SwitchBot API Error: ${data.message || 'Unknown error'}`);
        }
        
        return data.body?.deviceList || [];
      } catch (error) {
        console.error('SwitchBot API Error:', error);
        throw error;
      }
    }

    async function getDevices() {
      // Try to get live devices from SwitchBot API (with rate limiting protection)
      try {
        return await fetchSwitchBotDevices();
      } catch (error) {
        console.warn('SwitchBot API failed, using environment data:', error.message);
        // Fallback to environment data which includes SwitchBot readings
        const envData = await fetchEnvironmentData();
        return envData.filter(zone => zone.source === 'switchbot').map(zone => ({
          deviceId: zone.name || zone.zoneId,
          deviceName: zone.name || zone.zoneId,
          deviceType: 'SwitchBot Sensor',
          lastReading: zone
        }));
      }
    }

    async function getDeviceStatus(deviceId) {
      // For devices from environment data, return cached readings
      const envDevice = environmentData.find(zone => 
        (zone.name === deviceId || zone.zoneId === deviceId) && zone.source === 'switchbot'
      );
      
      if (envDevice) {
        return {
          statusCode: 100,
          body: {
            temperature: envDevice.temperature,
            humidity: envDevice.humidity,
            co2: envDevice.co2,
            battery: envDevice.battery,
            timestamp: envDevice.timestamp
          }
        };
      }
      
      // Try SwitchBot API as fallback (with rate limiting protection)
      try {
        const response = await fetch(`/api/switchbot/devices/${deviceId}/status`);
        if (response.status === 429) {
          throw new Error('Rate limit reached');
        }
        return await response.json();
      } catch (error) {
        console.warn(`Status fetch failed for ${deviceId}:`, error.message);
        return null;
      }
    }

    async function sendCommand(deviceId, command, parameter = '', commandType = 'command') {
      const response = await fetch(`/api/switchbot/devices/${deviceId}/commands`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          command,
          parameter,
          commandType
        })
      });

      const data = await response.json();
      if (!response.ok || data.statusCode !== 100) {
        const message = data?.message || `Command failed with status ${response.status}`;
        const error = new Error(message);
        error.data = data;
        error.status = response.status;
        throw error;
      }
      return data;
    }

    function showError(message) {
      const container = document.getElementById('errorContainer');
      container.innerHTML = `
        <div class="error-message">
          <strong>Error:</strong> ${message}
        </div>
      `;
    }

    function clearError() {
      document.getElementById('errorContainer').innerHTML = '';
    }

    function updateSyncStatus(status, isError = false) {
      const syncText = document.getElementById('syncText');
      const syncIndicator = document.getElementById('syncIndicator');
      
      syncText.textContent = status;
      
      if (isError) {
        syncIndicator.classList.add('error');
      } else {
        syncIndicator.classList.remove('error');
        syncIndicator.style.removeProperty('background');
        syncIndicator.style.removeProperty('animation');
      }
    }

    function formatReading(value, unit = '') {
      if (value === null || value === undefined) return '--';
      if (typeof value === 'boolean') return value ? 'Yes' : 'No';
      return `${value}${unit}`;
    }

    function createDeviceCard(device, status = null) {
      const isOnline = status && status.body;
      const readings = status?.body || {};
      
      const batteryLevel = readings.battery !== undefined ? readings.battery : null;
      const hasBattery = Number.isFinite(Number(batteryLevel));
      const batteryTone = hasBattery ? getBatteryTone(batteryLevel) : 'neutral';
      const batteryLabel = hasBattery ? formatBatteryLabel(batteryLevel) : 'External Power';
      const batteryDisplay = hasBattery ? `${formatNumber(batteryLevel, 0)}%` : 'Mains Power';
      const batteryMarkup = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryDisplay)}</span>`;

      // Enhanced device metadata
      const deviceModel = device.deviceType || 'Unknown';
      const firmwareVersion = readings.version?.BLE || device.version || '--';
      const lastUpdate = readings.lastUpdate || new Date().toISOString();
      const connectivity = readings.hubDeviceId ? 'Hub Connected' : 'Direct Connection';

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${deviceModel}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
              ${device.hubDeviceId ? `<p class="tiny" style="margin: 2px 0 0; color: #64748b;">Hub: ${device.hubDeviceId}</p>` : ''}
              ${firmwareVersion !== '--' ? `<p class="tiny" style="margin: 2px 0 0; color: #64748b;">FW: ${firmwareVersion}</p>` : ''}
            </div>
            <div style="text-align: right;">
              ${batteryMarkup}
              <div class="tiny" style="color: #64748b; margin-top: 2px;">${connectivity}</div>
              <button class="ghost tiny" onclick="refreshDevice('${device.deviceId}')" style="margin-top: 4px;">Refresh</button>
            </div>
          </div>
          
          ${createReadingsGrid(readings, device.deviceType)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last sync: ${new Date(lastUpdate).toLocaleTimeString()}
            </span>
            ${createDeviceControls(device)}
          </div>
        </div>
      `;
    }

    function createReadingsGrid(readings, deviceType) {
      const items = [];

      if (readings.temperature !== undefined) {
        items.push({ label: 'Temperature', value: formatReading(readings.temperature, '°C') });
      }

      if (readings.humidity !== undefined) {
        items.push({ label: 'Humidity', value: formatReading(readings.humidity, '%') });
      }

      if (readings.power !== undefined) {
        const state = typeof readings.power === 'string' ? readings.power.toUpperCase() : readings.power;
        const normalized = getPowerState(readings);
        const tone = normalized === 'on' ? 'positive' : normalized === 'off' ? 'warning' : '';
        items.push({ label: 'Power', value: normalized ? normalized.toUpperCase() : state, tone });
      }

      if (readings.voltage !== undefined) {
        items.push({ label: 'Voltage', value: formatReading(readings.voltage, 'V') });
      }

      if (readings.electricCurrent !== undefined) {
        items.push({ label: 'Current', value: formatReading(readings.electricCurrent, 'A') });
      }

      if (readings.electricityOfDay !== undefined) {
        items.push({ label: 'Daily Usage', value: formatReading(readings.electricityOfDay, 'kWh') });
      }

      if (readings.weight !== undefined) {
        items.push({ label: 'Power', value: formatReading(readings.weight, 'W') });
      }

      if (readings.moveDetected !== undefined) {
        items.push({ label: 'Motion', value: readings.moveDetected ? 'DETECTED' : 'NONE', tone: readings.moveDetected ? 'positive' : '' });
      }

      if (readings.brightness !== undefined) {
        items.push({ label: 'Light Level', value: formatReading(readings.brightness, '%') });
      }

      if (readings.lightLevel !== undefined) {
        items.push({ label: 'Illuminance', value: formatReading(readings.lightLevel, 'lux') });
      }

      if (readings.openState !== undefined) {
        items.push({ label: 'Door/Window', value: readings.openState === 'open' ? 'OPEN' : 'CLOSED' });
      }

      if (readings.version !== undefined && typeof readings.version === 'object' && readings.version.rssi) {
        items.push({ label: 'Signal', value: formatReading(readings.version.rssi, 'dBm') });
      }

      if (readings.version !== undefined && typeof readings.version === 'object' && readings.version.BLE) {
        items.push({ label: 'Firmware', value: readings.version.BLE });
      }

      if (items.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      }

      const content = items.map(item => {
        const toneAttr = item.tone ? ` data-tone="${item.tone}"` : '';
        return `
          <div class="reading-item"${toneAttr}>
            <div class="reading-value">${escapeHtml(String(item.value))}</div>
            <div class="reading-label">${escapeHtml(item.label)}</div>
          </div>
        `;
      }).join('');

      return `<div class="reading-grid">${content}</div>`;
    }

    function createDeviceControls(device) {
      const deviceType = String(device.deviceType || '').toLowerCase();
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);

      if (deviceType.includes('plug') || deviceType.includes('switch')) {
        return `
          <div class="row" style="gap: 4px;">
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOn')">ON</button>
            <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'turnOff')">OFF</button>
          </div>
        `;
      }

      if (deviceType.includes('bot')) {
        return `
          <button class="ghost tiny" onclick="sendDeviceCommand('${safeDeviceIdAttr}', 'press')">Press</button>
        `;
      }

      return '<span class="tiny" style="color: #64748b;">Read-only</span>';
    }

    async function loadDevices() {
      try {
        clearError();
        document.getElementById('loadingContainer').style.display = 'block';
        updateSyncStatus('Checking SwitchBot connection...');

        await loadDeviceMetadataIfNeeded().catch(error => {
          console.warn('Device metadata preload failed:', error);
        });

        // First try to get real SwitchBot devices from your farm
        try {
          const realDevices = await fetchSwitchBotDevices();
          if (realDevices && realDevices.length > 0) {
            updateSyncStatus(`Connected to ${realDevices.length} real SwitchBot devices from your farm`);
            devices = realDevices.map(device => ({
              ...device,
              isRealDevice: true,
              lastReading: {
                // Real devices get status separately via individual API calls
                lastUpdate: new Date().toISOString(),
                deviceType: device.deviceType,
                battery: device.battery || null,
                // Note: Temperature, humidity, etc. require separate status API calls
                message: "Click refresh to get current readings"
              }
            }));
            applyMetadataToAllDevices();
            renderDevicesFromAPI();
            document.getElementById('deviceCount').textContent = `${devices.length} real devices`;

            // Auto-fetch initial status data for a few devices only to avoid API limits
            setTimeout(() => {
              // Only fetch status for first 3 devices to avoid overloading API
              const devicesToFetch = devices.slice(0, 3);
              devicesToFetch.forEach((device, index) => {
                setTimeout(() => {
                  refreshDeviceData(device.deviceId);
                }, index * 2000); // Stagger requests by 2 seconds each
              });
            }, 2000); // Wait 2 seconds to avoid API rate limits
            
            return; // Success with real API
          }
        } catch (realApiError) {
          console.warn('Real SwitchBot API failed, falling back to environment data:', realApiError);
        }

        // Fallback to environment data
        updateSyncStatus('Loading environment data...');
        await fetchServerStatus();

        try {
          await ensureEnvironmentData(true);
        } catch (envError) {
          console.warn('Environment data fetch failed:', envError);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotEnvData = sourceData.filter(zone =>
          zone.source === 'switchbot' ||
          (zone.sensors && (zone.sensors.tempC || zone.sensors.rh || zone.sensors.co2))
        );

        if (switchbotEnvData.length > 0) {
          updateSyncStatus(`Found ${switchbotEnvData.length} environmental devices`);

          devices = switchbotEnvData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone.source === 'switchbot' ? zone : convertZoneToReading(zone)
          }));

          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = `${devices.length} devices`;

        } else {
          updateSyncStatus('No environmental data found');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
          
          showInfo('No environmental devices found. Configure Azure integration or start local polling to collect data.');
        }
        
      } catch (error) {
        console.error('Failed to load devices:', error);
        showError(`Failed to load environment data: ${error.message}`);
        updateSyncStatus('Connection failed', true);
      } finally {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    function convertZoneToReading(zone) {
      // Convert zone format to reading format for consistency
      const reading = {
        timestamp: zone.meta?.lastUpdated || new Date().toISOString(),
        battery: zone.meta?.battery,
        rssi: zone.meta?.rssi
      };

      if (zone.sensors?.tempC?.current !== undefined) {
        reading.temperature = zone.sensors.tempC.current;
      }
      if (zone.sensors?.rh?.current !== undefined) {
        reading.humidity = zone.sensors.rh.current;
      }
      if (zone.sensors?.co2?.current !== undefined) {
        reading.co2 = zone.sensors.co2.current;
      }
      if (zone.sensors?.vpd?.current !== undefined) {
        reading.vpd = zone.sensors.vpd.current;
      }

      return enrichReading(reading);
    }

    function renderDevicesFromEnvironment() {
      const container = document.getElementById('devicesContainer');

      applyMetadataToAllDevices();

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found in environment data</p>';
        return;
      }
      
      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.timestamp && 
          (Date.now() - new Date(reading.timestamp).getTime()) < 5 * 60 * 1000; // 5 minutes
        
        return createEnvironmentDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createEnvironmentDeviceCard(device, reading, isOnline) {
      const lastUpdate = reading?.timestamp ? new Date(reading.timestamp).toLocaleString() : 'Never';
      const hasBatteryLevel = Number.isFinite(Number(reading?.battery));
      const batteryTone = hasBatteryLevel ? getBatteryTone(reading.battery) : 'neutral';
      const batteryValue = hasBatteryLevel ? `${formatNumber(reading.battery, 0)}%` : 'Mains Power';
      const batteryLabel = hasBatteryLevel ? formatBatteryLabel(reading.battery) : 'External Power';
      const batteryBadge = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryValue)}</span>`;

      return `
        <div class="device-card">
          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <div class="row" style="align-items: center; margin-bottom: 4px;">
                <div class="device-status ${isOnline ? 'status-online' : 'status-offline'}"></div>
                <h3 style="margin: 0; font-size: 16px;">${device.deviceName}</h3>
              </div>
              <p class="tiny" style="margin: 0; color: #64748b;">${device.deviceType}</p>
              <p class="tiny" style="margin: 2px 0 0; color: #64748b;">ID: ${device.deviceId}</p>
            </div>
            <div style="text-align: right;">
              ${batteryBadge}
              <button class="ghost tiny" onclick="refreshEnvironmentData()" style="margin-top: 8px;">Refresh</button>
            </div>
          </div>

          ${createEnvironmentReadingsGrid(reading)}
          
          <div class="row" style="justify-content: space-between; align-items: center; margin-top: 12px;">
            <span class="tiny" style="color: #64748b;">
              Last updated: ${lastUpdate}
            </span>
            <span class="tiny" style="color: #64748b;">Environment Data</span>
          </div>
        </div>
      `;
    }

    function createEnvironmentReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available</p>';
      
      const readingItems = [];
      
      // Temperature
      if (reading.temperature !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.temperature, '°C')}</div>
            <div class="reading-label">Temperature</div>
          </div>
        `);
      }
      
      // Humidity
      if (reading.humidity !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.humidity, '%')}</div>
            <div class="reading-label">Humidity</div>
          </div>
        `);
      }
      
      // CO2
      if (reading.co2 !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.co2, ' ppm')}</div>
            <div class="reading-label">CO₂</div>
          </div>
        `);
      }
      
      // RSSI (signal strength)
      if (reading.rssi !== undefined) {
        readingItems.push(`
          <div class="reading-item">
            <div class="reading-value">${formatReading(reading.rssi, ' dBm')}</div>
            <div class="reading-label">Signal</div>
          </div>
        `);
      }
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor readings available</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    function renderDevicesFromAPI() {
      const container = document.getElementById('devicesContainer');

      if (devices.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b; grid-column: 1 / -1;">No SwitchBot devices found</p>';
        return;
      }

      applyMetadataToAllDevices();

      container.innerHTML = devices.map(device => {
        const reading = device.lastReading;
        const isOnline = reading && reading.lastUpdate &&
          (Date.now() - new Date(reading.lastUpdate).getTime()) < 5 * 60 * 1000; // 5 minutes

        return createAPIDeviceCard(device, reading, isOnline);
      }).join('');
    }

    function createAPIDeviceCard(device, reading, isOnline) {
      const metadata = getDeviceMetadata(getCanonicalDeviceId(device));
      enrichDeviceReading(device);
      const currentReading = device.lastReading || reading || {};
      const statusColor = isOnline ? '#0f9b74' : '#d14343';
      const statusText = isOnline ? 'ONLINE' : 'OFFLINE';
      const lastUpdate = currentReading?.lastUpdate ? new Date(currentReading.lastUpdate).toLocaleString() : 'Never';
      const deviceAvatar = getDeviceAvatar(device);
      const deviceCategory = getDeviceCategory(device.deviceType);
      const displayName = escapeHtml(device.displayName || device.deviceName || device.deviceId);
      const safeDeviceType = escapeHtml(device.deviceType || 'SwitchBot Device');
      const safeDeviceIdAttr = escapeAttribute(device.deviceId);
      const safeDeviceIdLabel = escapeHtml(device.deviceId);
      const zoneSelection = getZoneSelection(metadata, device);
      const roomSelection = getRoomSelection(metadata, device);
      const zoneOptionsHtml = renderSelectOptions(availableZones, zoneSelection.value, zoneSelection.label, 'Select Zone');
      const roomOptionsHtml = renderSelectOptions(availableRooms, roomSelection.value, roomSelection.label, 'Select Location');
      const isPlug = isPlugDevice(device.deviceType);
      const powerState = getPowerState(currentReading);
      const summaryHtml = createDeviceSummary(device, currentReading);
      const batteryLevel = currentReading?.battery;
      const hasBattery = Number.isFinite(Number(batteryLevel));
      const batteryDisplay = hasBattery ? `${formatNumber(batteryLevel, 0)}%` : 'Mains Power';
      const batteryTone = hasBattery ? getBatteryTone(batteryLevel) : 'neutral';
      const batteryLabel = hasBattery ? formatBatteryLabel(batteryLevel) : 'External Power';
      const batteryMarkup = `<span class="status-badge tone-${batteryTone}" title="${escapeAttribute(batteryLabel)}">${escapeHtml(batteryDisplay)}</span>`;
      const connectivityLabel = currentReading?.hubDeviceId ? 'Hub Connected' : 'Direct Connection';
      const safeConnectivity = escapeHtml(connectivityLabel);
      const statusBadge = `<span class="status-badge ${isOnline ? 'tone-positive' : 'tone-critical'}">${statusText}</span>`;
      const powerBadge = isPlug && powerState
        ? `<span class="status-badge ${powerState === 'on' ? 'tone-positive' : 'tone-warning'}">${escapeHtml(powerState.toUpperCase())}</span>`
        : '';
      const managedEquipmentValue = device.managedEquipment || '';
      const safeManagedEquipmentValue = escapeAttribute(managedEquipmentValue);
      const sourceBadge = device.isRealDevice
        ? '<span class="status-badge tone-positive">Real Farm Device</span>'
        : '<span class="status-badge tone-neutral">Live Demo API</span>';

      return `
        <div class="device-card" style="border-left: 4px solid ${statusColor}; opacity: ${isOnline ? 1 : 0.7};">
          <div class="device-header">
            <div style="display: flex; align-items: flex-start; gap: 12px; flex: 1; min-width: 0;">
              ${deviceAvatar}
              <div style="flex: 1; min-width: 0; overflow: hidden;">
                <h4 style="margin: 0 0 8px 0; color: #1e293b; font-size: 16px; font-weight: 600; cursor: pointer; line-height: 1.2; word-break: break-word;"
                    onclick="editDeviceName('${safeDeviceIdAttr}')"
                    title="Click to edit device name">
                  ${displayName}
                </h4>
                <div style="display: flex; flex-direction: column; gap: 4px;">
                  <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                    ${statusBadge}
                    ${powerBadge}
                  </div>
                  <div style="color: #64748b; font-size: 11px; line-height: 1.3; word-break: break-word;">
                    ${escapeHtml(deviceCategory)}
                  </div>
                </div>
              </div>
            </div>
            <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px; min-width: 100px;">
              ${batteryMarkup}
              <div class="tiny" style="color: #64748b;">${safeConnectivity}</div>
              <button onclick="refreshDeviceData('${safeDeviceIdAttr}')"
                      class="control-button secondary"
                      style="padding: 6px 12px; font-size: 12px;">
                Refresh
              </button>
            </div>
          </div>

          ${summaryHtml ? summaryHtml : ''}

          <div class="device-controls" style="margin: 12px 0;">
            ${createDeviceControls(device)}
          </div>

          <div class="device-info">
            <div style="margin-bottom: 12px;">
              <div style="display: flex; gap: 12px; margin-bottom: 8px;">
                <div style="flex: 1; min-width: 0;">
                  <label class="tiny" style="color: #64748b; display: block; margin-bottom: 4px;">Zone Assignment:</label>
                  <select onchange="updateDeviceZone('${safeDeviceIdAttr}', this.value)"
                          style="width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    ${zoneOptionsHtml}
                  </select>
                </div>
                <div style="flex: 1; min-width: 0;">
                  <label class="tiny" style="color: #64748b; display: block; margin-bottom: 4px;">Farm Location:</label>
                  <select onchange="updateDeviceLocation('${safeDeviceIdAttr}', this.value)"
                          style="width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    ${roomOptionsHtml}
                  </select>
                </div>
              </div>
              ${!isPlug ? '' : `
              <div style="margin-bottom: 8px;">
                <label class="tiny" style="color: #64748b; display: block; margin-bottom: 4px;">Managed Equipment:</label>
                <input type="text"
                       value="${safeManagedEquipmentValue}"
                       onchange="updateManagedEquipment('${safeDeviceIdAttr}', this.value)"
                       placeholder="e.g., Heater, Fan, Lights"
                       style="width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
              </div>
              `}
            </div>

            <div class="device-meta" style="background: #f8fafc; border-radius: 6px; padding: 10px; margin-bottom: 12px;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                <div><strong>Device ID:</strong><br><span style="word-break: break-all; font-size: 10px;">${safeDeviceIdLabel}</span></div>
                <div><strong>Type:</strong><br><span style="font-size: 10px;">${safeDeviceType}</span></div>
                <div><strong>MAC:</strong><br><span style="font-size: 10px;">${escapeHtml(device.macAddress || 'N/A')}</span></div>
                <div><strong>Cloud:</strong><br><span style="font-size: 10px;">${escapeHtml(device.cloudService || 'SwitchBot')}</span></div>
              </div>
            </div>

            ${createAPIReadingsGrid(currentReading)}
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px; flex-wrap: wrap; gap: 8px; border-top: 1px solid #e2e8f0; padding-top: 8px;">
            <span class="tiny" style="color: #64748b; font-size: 10px;">
              Last updated: ${escapeHtml(lastUpdate)}
            </span>
            ${sourceBadge}
          </div>
        </div>
      `;
    }

    function createAPIReadingsGrid(reading) {
      if (!reading) return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No readings available - click refresh to get data</p>';
      
      // Handle real device messages
      if (reading.message) {
        const safeMessage = escapeHtml(reading.message);
        return `
          <div class="live-indicator">
            <span class="pulse-dot"></span>
            <span>${safeMessage}</span>
          </div>
          <p class="tiny" style="margin: 6px 0 12px; color: #0f9b74;">
            This is a real device from your farm. Use the Refresh action to capture the latest sensor readings.
          </p>
        `;
      }
      
      const readingItems = [];
      
      // Show all available data fields with enhanced formatting
      Object.keys(reading).forEach(key => {
        if (key === 'lastUpdate' || key === 'message' || key === 'deviceId') return;
        
        const value = reading[key];
        if (value === undefined || value === null) return;
        
        const normalizedKey = key.toLowerCase();
        let displayValue = value;
        let unit = '';
        let label = '';
        let tone = '';

        switch (normalizedKey) {
          case 'temperature':
            unit = '°C';
            label = 'Temperature';
            break;
          case 'humidity':
            unit = '%';
            label = 'Humidity';
            break;
          case 'vpd':
            unit = ' kPa';
            label = 'VPD';
            displayValue = formatNumber(value, 2);
            break;
          case 'co2':
            unit = ' ppm';
            label = 'CO₂';
            if (Number(value) > 1200) tone = 'warning';
            break;
          case 'power':
            unit = typeof value === 'number' ? 'W' : '';
            label = 'Power';
            if (typeof value === 'string') {
              const normalized = getPowerState({ power: value });
              displayValue = normalized ? normalized.toUpperCase() : value.toUpperCase();
              tone = normalized === 'on' ? 'positive' : normalized === 'off' ? 'warning' : tone;
            }
            break;
          case 'voltage':
            unit = 'V';
            label = 'Voltage';
            break;
          case 'electriccurrent':
          case 'current':
            unit = 'A';
            label = 'Current';
            break;
          case 'electricityofday':
            unit = 'kWh';
            label = 'Daily Usage';
            break;
          case 'weight':
            unit = 'W';
            label = 'Wattage';
            break;
          case 'battery':
            unit = '%';
            label = 'Battery';
            tone = getBatteryTone(value);
            break;
          case 'position':
            unit = '%';
            label = 'Position';
            break;
          case 'version':
            label = 'Firmware';
            displayValue = typeof value === 'object' ? value.BLE || value.WiFi || JSON.stringify(value) : value;
            break;
          case 'openstate':
            label = 'Status';
            displayValue = value === 'open' ? 'OPEN' : 'CLOSED';
            break;
          case 'movedetected':
            label = 'Motion';
            displayValue = value ? 'DETECTED' : 'NONE';
            tone = value ? 'positive' : '';
            break;
          case 'brightness':
            label = 'Brightness';
            unit = '%';
            break;
          case 'lightlevel':
          case 'lightintensity':
            label = 'Illuminance';
            unit = 'lux';
            break;
          case 'volume':
            label = 'Volume';
            unit = Number(value) > 1 ? 'dB' : '';
            break;
          case 'scale':
            label = 'Weight';
            unit = 'kg';
            break;
          case 'doorstate':
            label = 'Door';
            displayValue = Number(value) === 1 ? 'OPEN' : 'CLOSED';
            break;
          case 'calibration':
            label = 'Calibration';
            displayValue = value ? 'YES' : 'NO';
            break;
          case 'lackpower':
            label = 'Power Status';
            displayValue = value ? 'LOW POWER' : 'OK';
            tone = value ? 'critical' : 'positive';
            break;
          default:
            label = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
        }

        const toneAttr = tone ? ` data-tone="${tone}"` : '';
        const formattedValue = formatReading(displayValue, unit);
        readingItems.push(`
          <div class="reading-item"${toneAttr}>
            <div class="reading-value">${escapeHtml(String(formattedValue))}</div>
            <div class="reading-label">${escapeHtml(label)}</div>
          </div>
        `);
      });
      
      if (readingItems.length === 0) {
        return '<p class="tiny" style="color: #64748b; text-align: center; margin: 12px 0;">No sensor data available - click refresh to get readings</p>';
      }
      
      return `<div class="reading-grid">${readingItems.join('')}</div>`;
    }

    async function refreshEnvironmentData() {
      try {
        updateSyncStatus('Refreshing environment data...');
        try {
          await ensureEnvironmentData(true);
        } catch (error) {
          console.warn('Environment refresh failed:', error);
        }

        const sourceData = Array.isArray(environmentData) ? environmentData : [];
        const switchbotData = sourceData.filter(zone => zone.source === 'switchbot');

        if (switchbotData.length > 0) {
          devices = switchbotData.map(zone => ({
            deviceId: zone.id || zone.name || zone.zoneId,
            deviceName: zone.name || zone.id || zone.zoneId,
            deviceType: zone.source === 'switchbot' ? 'SwitchBot Environmental Sensor' : 'Environmental Sensor',
            lastReading: zone
          }));
          applyMetadataToAllDevices();
          renderDevicesFromEnvironment();
          updateSyncStatus(`Refreshed ${devices.length} devices`);
          document.getElementById('deviceCount').textContent = `${devices.length} devices from environment data`;
        } else {
          updateSyncStatus('No SwitchBot data in environment');
          devices = [];
          renderDevicesFromEnvironment();
          document.getElementById('deviceCount').textContent = 'No devices found';
        }
      } catch (error) {
        console.error('Failed to refresh environment data:', error);
        updateSyncStatus('Refresh failed', true);
      }
    }

    function startAutoRefresh() {
      if (syncInterval) clearInterval(syncInterval);
      syncInterval = setInterval(refreshEnvironmentData, 30000);
    }

    function stopAutoRefresh() {
      if (syncInterval) {
        clearInterval(syncInterval);
        syncInterval = null;
      }
    }

    function showInfo(message) {
      const container = document.getElementById('infoContainer');
      container.innerHTML = `<div class="info-message"><strong>Info:</strong> ${message}</div>`;
    }

    function clearError() {
      document.getElementById('errorContainer').innerHTML = '';
      document.getElementById('infoContainer').innerHTML = '';
    }

    function startSwitchBotPolling() {
      const button = document.getElementById('btnStartPolling');
      if (button.textContent === 'Start Polling') {
        // Start polling
        showInfo('<strong>Starting SwitchBot polling...</strong><br>Collecting device data from local mock API...');
        button.textContent = 'Stop Polling';
        button.style.backgroundColor = '#dc3545';
        
        // Start the polling interval
        window.switchBotPollingInterval = setInterval(async () => {
          try {
            // Instead of loading all devices, just update the device list without fetching all statuses
            const realDevices = await fetchSwitchBotDevices();
            if (realDevices && realDevices.length > 0) {
              devices = realDevices.map(device => ({
                ...device,
                isRealDevice: true,
                lastReading: devices.find(d => d.deviceId === device.deviceId)?.lastReading || {
                  lastUpdate: new Date().toISOString(),
                  message: "Click refresh to get current readings"
                }
              }));
              applyMetadataToAllDevices();
              renderDevicesFromAPI();
              showInfo(`<strong>Polling active</strong><br>Last update: ${new Date().toLocaleTimeString()}<br>Device list refreshed. Click refresh on cards for live data.`);
            }
          } catch (error) {
            showError(`Polling error: ${error.message}`);
          }
        }, 30000); // Poll every 30 seconds instead of 10
        
        // Immediate first poll
        loadDevices();
        
      } else {
        // Stop polling
        if (window.switchBotPollingInterval) {
          clearInterval(window.switchBotPollingInterval);
          window.switchBotPollingInterval = null;
        }
        button.textContent = 'Start Polling';
        button.style.backgroundColor = '#007bff';
        showInfo('<strong>⏹️ Polling stopped</strong><br>Click "Start Polling" to resume data collection.');
      }
    }

    function getSwitchBotToken() {
      return "4e6fc805b4a0dd7ed693af1dcf89d9731113d4706b2d796759aafe09cf8f07aed370d35bab4fb4799e1bda57d03c0aed";
    }

    function getSwitchBotSecret() {
      return "141c0bc9906ab1f4f73dd9f0c298046b";
    }

    async function fetchServerStatus() {
      try {
        const response = await fetch('/status');
        if (response.ok) {
          const status = await response.json();
          const configSpan = document.getElementById('currentConfig');
          if (configSpan) {
            configSpan.innerHTML = `
              <strong>Environment Source:</strong> ${status.envSource || 'local'}<br>
              ${status.azureLatestUrl ? `<strong>Azure URL:</strong> ${status.azureLatestUrl}<br>` : ''}
              <strong>Server:</strong> ${status.controller || 'unknown'}
            `;
          }
        }
      } catch (error) {
        console.error('Failed to fetch server status:', error);
      }
    }

    // Global functions for onclick handlers
    window.refreshEnvironmentData = refreshEnvironmentData;
    window.startSwitchBotPolling = startSwitchBotPolling;

    // Event listeners
    document.addEventListener('DOMContentLoaded', async () => {
      document.getElementById('btnRefresh').addEventListener('click', refreshEnvironmentData);
      document.getElementById('btnStartPolling').addEventListener('click', startSwitchBotPolling);
      document.getElementById('btnOpenMain').addEventListener('click', () => {
        window.open('/', '_blank');
      });

      try {
        await loadReferenceData();
      } catch (error) {
        console.warn('Initial reference data load failed:', error);
      }

      await loadDevices();
      // Disabled auto-refresh to prevent conflicts - use manual refresh instead
      // startAutoRefresh();
    });

    window.addEventListener('beforeunload', () => {
      stopAutoRefresh();
      // Stop any polling intervals
      if (window.switchBotPollingInterval) {
        clearInterval(window.switchBotPollingInterval);
      }
    });

    // Helper functions for device management
    function getDeviceAvatar(device) {
      const type = String(device?.deviceType || '').toLowerCase();
      let toneClass = '';
      let label = 'SB';

      if (type.includes('meter') || type.includes('sensor') || type.includes('monitor')) {
        label = 'ENV';
      } else if (type.includes('plug') || type.includes('switch')) {
        label = 'PWR';
        toneClass = 'tone-energy';
      } else if (type.includes('bot')) {
        label = 'BOT';
        toneClass = 'tone-automation';
      } else if (type.includes('hub')) {
        label = 'HUB';
        toneClass = 'tone-energy';
      } else if (type.includes('camera')) {
        label = 'CAM';
        toneClass = 'tone-safety';
      } else if (type.includes('lock')) {
        label = 'LOCK';
        toneClass = 'tone-safety';
      } else {
        const fallbackName = String(device?.displayName || device?.deviceName || device?.deviceId || 'SB');
        const initials = fallbackName
          .split(/\s+/)
          .filter(Boolean)
          .map(part => part[0])
          .join('')
          .slice(0, 3)
          .toUpperCase();
        label = initials || 'SB';
      }

      const tone = toneClass ? ` ${toneClass}` : '';
      return `<span class="device-avatar${tone}">${escapeHtml(label)}</span>`;
    }

    function getDeviceCategory(deviceType) {
      const type = String(deviceType || '').toLowerCase();
      if (type.includes('meter') || type.includes('sensor') || type.includes('monitor')) {
        return 'Environmental Monitoring';
      } else if (type.includes('plug') || type.includes('switch')) {
        return 'Power Control';
      } else if (type.includes('bot')) {
        return 'Mechanical Control';
      } else if (type.includes('hub')) {
        return 'Central Hub';
      } else {
        return 'Smart Device';
      }
    }

    // Device editing functions
    async function editDeviceName(deviceId) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const currentName = device.displayName || device.deviceName || deviceId;
      const newName = prompt('Enter new device name:', currentName);
      if (!newName || newName === currentName) {
        return;
      }

      try {
        const metadata = await persistDeviceMetadata(device, { name: newName, deviceName: newName });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.displayName = newName;
        }
        renderDevicesFromAPI();
        showInfo(`Updated device name to ${escapeHtml(newName)}.`);
      } catch (error) {
        console.error('Failed to update device name:', error);
        showError(`Failed to update device name: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }

    async function updateDeviceLocation(deviceId, locationValue) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const option = findRoomOption(locationValue);
      const locationName = option ? option.name : '';

      try {
        const metadata = await persistDeviceMetadata(device, {
          room: locationName || null,
          roomName: locationName || null,
          roomId: option ? option.id || option.value : null,
          roomSlug: option ? option.value : null,
          location: locationName || null
        });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.farmLocation = locationName;
          device.farmLocationId = option ? option.value : '';
          syncDeviceCardSchema(device);
          recalculateSensorWeights();
        }
        renderDevicesFromAPI();
        const safeDeviceName = escapeHtml(device.displayName || device.deviceName || deviceId);
        if (locationName) {
          showInfo(`Updated location for ${safeDeviceName} to ${escapeHtml(locationName)}.`);
        } else {
          showInfo(`Cleared farm location for ${safeDeviceName}.`);
        }
      } catch (error) {
        console.error('Failed to update device location:', error);
        showError(`Failed to update device location: ${escapeHtml(error.message || 'Unknown error')}`);
        applyMetadataToDevice(device);
        renderDevicesFromAPI();
      }
    }

    async function updateDeviceZone(deviceId, zoneValue) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const option = findZoneOption(zoneValue);
      const zoneName = option ? option.name : '';

      try {
        const metadata = await persistDeviceMetadata(device, {
          zone: zoneName || null,
          zoneName: zoneName || null,
          zoneId: option ? option.id || option.value : null,
          zoneSlug: option ? option.value : null
        });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.zoneName = zoneName;
          device.zoneId = option ? option.value : '';
          syncDeviceCardSchema(device);
          recalculateSensorWeights();
        }
        renderDevicesFromAPI();
        const safeDeviceName = escapeHtml(device.displayName || device.deviceName || deviceId);
        if (zoneName) {
          showInfo(`Assigned ${safeDeviceName} to ${escapeHtml(zoneName)}.`);
        } else {
          showInfo(`Cleared zone assignment for ${safeDeviceName}.`);
        }
      } catch (error) {
        console.error('Failed to update device zone:', error);
        showError(`Failed to update zone: ${escapeHtml(error.message || 'Unknown error')}`);
        applyMetadataToDevice(device);
        renderDevicesFromAPI();
      }
    }

    async function updateManagedEquipment(deviceId, equipment) {
      const device = devices.find(d => d.deviceId === deviceId);
      if (!device) return;

      const trimmed = equipment && equipment.trim().length > 0 ? equipment.trim() : '';

      try {
        const metadata = await persistDeviceMetadata(device, {
          managedEquipment: trimmed || null,
          equipment: trimmed || null
        });
        if (metadata) {
          applyMetadataToDevice(device, metadata);
        } else {
          device.managedEquipment = trimmed;
          syncDeviceCardSchema(device);
        }
        renderDevicesFromAPI();
        const safeDeviceName = escapeHtml(device.displayName || device.deviceName || deviceId);
        if (trimmed) {
          showInfo(`Updated managed equipment for ${safeDeviceName}: ${escapeHtml(trimmed)}.`);
        } else {
          showInfo(`Cleared managed equipment for ${safeDeviceName}.`);
        }
      } catch (error) {
        console.error('Failed to update managed equipment:', error);
        showError(`Failed to update managed equipment: ${escapeHtml(error.message || 'Unknown error')}`);
        applyMetadataToDevice(device);
        renderDevicesFromAPI();
      }
    }

    // Rate limiting for API calls
    const lastApiCall = {};
    const API_RATE_LIMIT = 3000; // 3 seconds between calls per device

    async function refreshDeviceData(deviceId) {
      try {
        // Check rate limiting
        const now = Date.now();
        if (lastApiCall[deviceId] && (now - lastApiCall[deviceId]) < API_RATE_LIMIT) {
          showInfo(`⏳ Please wait ${Math.ceil((API_RATE_LIMIT - (now - lastApiCall[deviceId])) / 1000)} seconds before refreshing this device again`);
          return;
        }

        lastApiCall[deviceId] = now;
        const targetDevice = devices.find(d => d.deviceId === deviceId);
        const safeDeviceLabel = escapeHtml(targetDevice?.displayName || targetDevice?.deviceName || deviceId);
        showInfo(`Refreshing data for ${safeDeviceLabel}...`);

        // Call SwitchBot status API for individual device
        const response = await fetch(`/api/switchbot/devices/${deviceId}/status`);
        const data = await response.json();

        if (data.statusCode === 100) {
          // Update device with fresh data
          const device = targetDevice || devices.find(d => d.deviceId === deviceId);
          if (device) {
            const merged = {
              ...device.lastReading,
              ...data.body,
              lastUpdate: new Date().toISOString()
            };
            if (
              merged.vpd === undefined &&
              typeof merged.temperature === 'number' &&
              typeof merged.humidity === 'number'
            ) {
              const computedVpd = computeVPD(merged.temperature, merged.humidity);
              if (computedVpd !== null) {
                merged.vpd = computedVpd;
              }
            }
            if (merged.weight !== undefined && merged.wattage === undefined) {
              merged.wattage = merged.weight;
            }
            device.lastReading = enrichReading(merged);
            applyMetadataToDevice(device);
            renderDevicesFromAPI();
            const refreshedLabel = escapeHtml(device.displayName || device.deviceName || deviceId);
            showInfo(`Refreshed data for ${refreshedLabel}.`);
          }
        } else {
          throw new Error(data.message || 'Failed to get device status');
        }
      } catch (error) {
        console.error('Device refresh error:', error);
        showError(`Failed to refresh device data: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }

    async function controlDevice(deviceId, command) {
      try {
        const device = devices.find(d => d.deviceId === deviceId);
        const deviceName = device ? device.displayName || device.deviceName : deviceId;
        const safeCommand = escapeHtml(command);
        const safeDeviceName = escapeHtml(deviceName);

        showInfo(`Sending ${safeCommand} command to ${safeDeviceName}...`);

        const response = await fetch(`/api/switchbot/devices/${deviceId}/commands`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            command: command,
            parameter: 'default'
          })
        });
        
        const data = await response.json();

        if (data.statusCode === 100) {
          showInfo(`Successfully sent ${safeCommand} command to ${safeDeviceName}.`);
          // Refresh device data after command
          setTimeout(() => refreshDeviceData(deviceId), 2000);
        } else {
          throw new Error(data.message || 'Command failed');
        }
      } catch (error) {
        console.error('Failed to control device:', error);
        showError(`Failed to control device: ${escapeHtml(error.message || 'Unknown error')}`);
      }
    }
  </script>
</body>
</html>